[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK.\r\n\r\nIf you're moving things around in net.h to add lock annotations, might be worth moving `NetEventsInterface` to after the `CNode` definition, and making it `virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;`.\r\n\r\nMoving `IsPeerAddrLocalGood` and `AdvertiseLocal` later as well would allow removing the `class CNode;` forward declaration entirely.\r\n\r\nIt would be nice if there were some easy way to review pointer-becomes-reference changes.",
      "created_at" : "2021-01-06T08:33:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755162168",
      "id" : 755162168,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NTE2MjE2OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-06T08:33:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755162168",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> It would be nice if there were some easy way to review pointer-becomes-reference changes.\r\n\r\nApart from `--word-diff-regex=.`?\r\n\r\n> SendMessages ...\r\n\r\nThanks, done",
      "created_at" : "2021-01-06T08:46:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755167546",
      "id" : 755167546,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NTE2NzU0Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-06T08:46:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755167546",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20811 (refactor: move net_processing implementation details out of header by ajtowns)\n* #20786 (net: [refactor] Prefer integral types in CNodeStats by MarcoFalke)\n* #20729 (p2p: standardize on outbound-{full, block}-relay connection type naming by jonatack)\n* #20724 (Cleanup of -debug=net log messages by ajtowns)\n* #20646 (doc: refer to BIPs 339/155 in feature negotiation by jonatack)\n* #20364 (Follow-ups to 19107 by troygiorshev)\n* #20234 (net: don't extra bind for Tor if binds are restricted by vasild)\n* #20228 (addrman: Make addrman a top-level component by jnewbery)\n* #20196 (net: fix GetListenPort() to derive the proper port by vasild)\n* #19843 (Refactoring and minor improvement for self-advertisements by naumenkogs)\n* #19460 (multiprocess: Add bitcoin-wallet -ipcconnect option by ryanofsky)\n* #19315 ([tests] Allow outbound & block-relay-only connections in functional tests. by amitiuttarwar)\n* #18819 (net: Replace cs_feeFilter with simple std::atomic by MarcoFalke)\n* #18077 (net: Add NAT-PMP port forwarding support by hebasto)\n* #10102 ([experimental] Multiprocess bitcoin by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2021-01-06T12:03:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755260797",
      "id" : 755260797,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NTI2MDc5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-07T08:57:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755260797",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r552621025"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/552621025"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you touch this again, add a blank line after the class declaration.",
      "commit_id" : "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "created_at" : "2021-01-06T13:40:13Z",
      "diff_hunk" : "@@ -180,1041 +180,1040 @@ enum class ConnectionType {\n     ADDR_FETCH,\n };\n \n-class NetEventsInterface;\n-class CConnman\n-{\n-public:\n-\n-    enum NumConnections {\n-        CONNECTIONS_NONE = 0,\n-        CONNECTIONS_IN = (1U << 0),\n-        CONNECTIONS_OUT = (1U << 1),\n-        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n-    };\n-\n-    struct Options\n-    {\n-        ServiceFlags nLocalServices = NODE_NONE;\n-        int nMaxConnections = 0;\n-        int m_max_outbound_full_relay = 0;\n-        int m_max_outbound_block_relay = 0;\n-        int nMaxAddnode = 0;\n-        int nMaxFeeler = 0;\n-        CClientUIInterface* uiInterface = nullptr;\n-        NetEventsInterface* m_msgproc = nullptr;\n-        BanMan* m_banman = nullptr;\n-        unsigned int nSendBufferMaxSize = 0;\n-        unsigned int nReceiveFloodSize = 0;\n-        uint64_t nMaxOutboundLimit = 0;\n-        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n-        std::vector<std::string> vSeedNodes;\n-        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n-        std::vector<NetWhitebindPermissions> vWhiteBinds;\n-        std::vector<CService> vBinds;\n-        std::vector<CService> onion_binds;\n-        bool m_use_addrman_outgoing = true;\n-        std::vector<std::string> m_specified_outgoing;\n-        std::vector<std::string> m_added_nodes;\n-        std::vector<bool> m_asmap;\n-    };\n-\n-    void Init(const Options& connOptions) {\n-        nLocalServices = connOptions.nLocalServices;\n-        nMaxConnections = connOptions.nMaxConnections;\n-        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n-        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n-        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n-        nMaxAddnode = connOptions.nMaxAddnode;\n-        nMaxFeeler = connOptions.nMaxFeeler;\n-        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n-        clientInterface = connOptions.uiInterface;\n-        m_banman = connOptions.m_banman;\n-        m_msgproc = connOptions.m_msgproc;\n-        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n-        {\n-            LOCK(cs_totalBytesSent);\n-            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-        }\n-        vWhitelistedRange = connOptions.vWhitelistedRange;\n-        {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n-        }\n-        m_onion_binds = connOptions.onion_binds;\n-    }\n-\n-    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n-    ~CConnman();\n-    bool Start(CScheduler& scheduler, const Options& options);\n-\n-    void StopThreads();\n-    void StopNodes();\n-    void Stop()\n-    {\n-        StopThreads();\n-        StopNodes();\n-    };\n-\n-    void Interrupt();\n-    bool GetNetworkActive() const { return fNetworkActive; };\n-    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n-    void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n-    bool CheckIncomingNonce(uint64_t nonce);\n-\n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n-\n-    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n-\n-    using NodeFn = std::function<void(CNode*)>;\n-    void ForEachNode(const NodeFn& func)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    void ForEachNode(const NodeFn& func) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+void Discover();\n+void StartMapPort();\n+void InterruptMapPort();\n+void StopMapPort();\n+uint16_t GetListenPort();\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+enum\n+{\n+    LOCAL_NONE,   // unknown\n+    LOCAL_IF,     // address a local interface listens on\n+    LOCAL_BIND,   // address explicit bound to\n+    LOCAL_UPNP,   // address reported by UPnP\n+    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n \n-    // Addrman functions\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n-    /**\n-     * Cache is used to minimize topology leaks, so it should\n-     * be used for all non-trusted calls, for example, p2p.\n-     * A non-malicious call (from RPC or a peer with addr permission) should\n-     * call the function without a parameter to avoid using the cache.\n-     */\n-    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n+    LOCAL_MAX\n+};\n \n-    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n-    // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+bool IsPeerAddrLocalGood(CNode *pnode);\n+void AdvertiseLocal(CNode *pnode);\n \n-    void StartExtraBlockRelayPeers() {\n-        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n-        m_start_extra_block_relay_peers = true;\n-    }\n+/**\n+ * Mark a network as reachable or unreachable (no automatic connects to it)\n+ * @note Networks are reachable by default\n+ */\n+void SetReachable(enum Network net, bool reachable);\n+/** @returns true if the network is reachable, false otherwise */\n+bool IsReachable(enum Network net);\n+/** @returns true if the address is in a reachable network, false otherwise */\n+bool IsReachable(const CNetAddr& addr);\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n-    // to false, we may have extra peers that we wish to disconnect). This may\n-    // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n-    // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n-    // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n+bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+void RemoveLocal(const CService& addr);\n+bool SeenLocal(const CService& addr);\n+bool IsLocal(const CService& addr);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n+CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n \n-    bool AddNode(const std::string& node);\n-    bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    size_t GetNodeCount(NumConnections num);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n-    bool DisconnectNode(const std::string& node);\n-    bool DisconnectNode(const CSubNet& subnet);\n-    bool DisconnectNode(const CNetAddr& addr);\n-    bool DisconnectNode(NodeId id);\n+extern bool fDiscover;\n+extern bool fListen;\n \n-    //! Used to convey which local services we are offering peers during node\n-    //! connection.\n-    //!\n-    //! The data returned by this is used in CNode construction,\n-    //! which is used to advertise which services we are offering\n-    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n-    ServiceFlags GetLocalServices() const;\n+/** Subversion as sent to the P2P network in `version` messages */\n+extern std::string strSubVersion;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+struct LocalServiceInfo {\n+    int nScore;\n+    int nPort;\n+};\n \n-    //! check if the outbound target is reached\n-    //! if param historicalBlockServingLimit is set true, the function will\n-    //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+extern RecursiveMutex cs_mapLocalHost;\n+extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n \n-    //! response the bytes left in the current max outbound cycle\n-    //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+extern const std::string NET_MESSAGE_COMMAND_OTHER;\n+typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n \n-    //! returns the time left in the current max outbound cycle\n-    //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+class CNodeStats\n+{\n+public:\n+    NodeId nodeid;\n+    ServiceFlags nServices;\n+    bool fRelayTxes;\n+    int64_t nLastSend;\n+    int64_t nLastRecv;\n+    int64_t nLastTXTime;\n+    int64_t nLastBlockTime;\n+    int64_t nTimeConnected;\n+    int64_t nTimeOffset;\n+    std::string addrName;\n+    int nVersion;\n+    std::string cleanSubVer;\n+    bool fInbound;\n+    bool m_bip152_highbandwidth_to;\n+    bool m_bip152_highbandwidth_from;\n+    int m_starting_height;\n+    uint64_t nSendBytes;\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    uint64_t nRecvBytes;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    NetPermissionFlags m_permissionFlags;\n+    int64_t m_ping_usec;\n+    int64_t m_ping_wait_usec;\n+    int64_t m_min_ping_usec;\n+    CAmount minFeeFilter;\n+    // Our address, as reported by the peer\n+    std::string addrLocal;\n+    // Address of this peer\n+    CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n+    // Network the peer connected through\n+    Network m_network;\n+    uint32_t m_mapped_as;\n+    std::string m_conn_type_string;\n+};\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n \n-    /** Get a unique deterministic randomizer. */\n-    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-    unsigned int GetReceiveFloodSize() const;\n+/** Transport protocol agnostic message container.\n+ * Ideally it should only contain receive time, payload,\n+ * command and size.\n+ */\n+class CNetMessage {\n+public:\n+    CDataStream m_recv;                  //!< received message data\n+    std::chrono::microseconds m_time{0}; //!< time of message receipt\n+    uint32_t m_message_size{0};          //!< size of the payload\n+    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n+    std::string m_command;\n \n-    void WakeMessageHandler();\n+    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n \n-    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n-        Works assuming that a single interval is used.\n-        Variable intervals will result in privacy decrease.\n-    */\n-    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n+    void SetVersion(int nVersionIn)\n+    {\n+        m_recv.SetVersion(nVersionIn);\n+    }\n+};\n \n-    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n+/** The TransportDeserializer takes care of holding and deserializing the\n+ * network receive buffer. It can deserialize the network buffer into a\n+ * transport protocol agnostic CNetMessage (command & payload)\n+ */\n+class TransportDeserializer {\n+public:\n+    // returns true if the current deserialization is complete\n+    virtual bool Complete() const = 0;\n+    // set the serialization context version\n+    virtual void SetVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer */\n+    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    // decomposes a message from the context\n+    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n+    virtual ~TransportDeserializer() {}\n+};\n \n+class V1TransportDeserializer final : public TransportDeserializer\n+{\n private:\n-    struct ListenSocket {\n-    public:\n-        SOCKET socket;\n-        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n-        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n-    private:\n-        NetPermissionFlags m_permissions;\n-    };\n-\n-    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n-    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n-    bool InitBinds(\n-        const std::vector<CService>& binds,\n-        const std::vector<NetWhitebindPermissions>& whiteBinds,\n-        const std::vector<CService>& onion_binds);\n-\n-    void ThreadOpenAddedConnections();\n-    void AddAddrFetch(const std::string& strDest);\n-    void ProcessAddrFetch();\n-    void ThreadOpenConnections(std::vector<std::string> connect);\n-    void ThreadMessageHandler();\n-    void AcceptConnection(const ListenSocket& hListenSocket);\n-    void DisconnectNodes();\n-    void NotifyNumConnectionsChanged();\n-    void InactivityCheck(CNode *pnode);\n-    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketHandler();\n-    void ThreadSocketHandler();\n-    void ThreadDNSAddressSeed();\n-\n-    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n-\n-    CNode* FindNode(const CNetAddr& ip);\n-    CNode* FindNode(const CSubNet& subNet);\n-    CNode* FindNode(const std::string& addrName);\n-    CNode* FindNode(const CService& addr);\n-\n-    /**\n-     * Determine whether we're already connected to a given address, in order to\n-     * avoid initiating duplicate connections.\n-     */\n-    bool AlreadyConnectedToAddress(const CAddress& addr);\n-\n-    bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n-    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n-\n-    void DeleteNode(CNode* pnode);\n+    const CChainParams& m_chain_params;\n+    const NodeId m_node_id; // Only for logging\n+    mutable CHash256 hasher;\n+    mutable uint256 data_hash;\n+    bool in_data;                   // parsing header (false) or data (true)\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    CDataStream vRecv;              // received message data\n+    unsigned int nHdrPos;\n+    unsigned int nDataPos;\n \n-    NodeId GetNewNodeId();\n+    const uint256& GetMessageHash() const;\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n \n-    size_t SocketSendData(CNode *pnode) const;\n-    void DumpAddresses();\n+    void Reset() {\n+        vRecv.clear();\n+        hdrbuf.clear();\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+        data_hash.SetNull();\n+        hasher.Reset();\n+    }\n \n-    // Network stats\n-    void RecordBytesRecv(uint64_t bytes);\n-    void RecordBytesSent(uint64_t bytes);\n+public:\n+    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n+        : m_chain_params(chain_params),\n+          m_node_id(node_id),\n+          hdrbuf(nTypeIn, nVersionIn),\n+          vRecv(nTypeIn, nVersionIn)\n+    {\n+        Reset();\n+    }\n \n-    /**\n-     * Return vector of current BLOCK_RELAY peers.\n-     */\n-    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n+    bool Complete() const override\n+    {\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+};\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n+/** The TransportSerializer prepares messages for the network transport\n+ */\n+class TransportSerializer {\n+public:\n+    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n+    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n+    virtual ~TransportSerializer() {}\n+};\n \n-    // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n-    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n+class V1TransportSerializer  : public TransportSerializer {\n+public:\n+    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n \n-    // outbound limit & stats\n-    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n-    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n-    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n+/** Information about a peer */\n+class CNode\n+{\n+    friend class CConnman;\n+    friend struct ConnmanTestMsg;\n \n-    // P2P timeout in seconds\n-    int64_t m_peer_connect_timeout;\n+public:\n+    std::unique_ptr<TransportDeserializer> m_deserializer;\n+    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // Whitelisted ranges. Any node connecting from these is automatically\n-    // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+    // socket\n+    std::atomic<ServiceFlags> nServices{NODE_NONE};\n+    SOCKET hSocket GUARDED_BY(cs_hSocket);\n+    /** Total size of all vSendMsg entries */\n+    size_t nSendSize GUARDED_BY(cs_vSend){0};\n+    /** Offset inside the first vSendMsg already sent */\n+    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n+    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n+    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n+    Mutex cs_vSend;\n+    Mutex cs_hSocket;\n+    Mutex cs_vRecv;\n \n-    unsigned int nSendBufferMaxSize{0};\n-    unsigned int nReceiveFloodSize{0};\n+    RecursiveMutex cs_vProcessMsg;\n+    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n+    size_t nProcessQueueSize{0};\n \n-    std::vector<ListenSocket> vhListenSocket;\n-    std::atomic<bool> fNetworkActive{true};\n-    bool fAddressesInitialized{false};\n-    CAddrMan addrman;\n-    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n-    RecursiveMutex m_addr_fetches_mutex;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n-    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable RecursiveMutex cs_vNodes;\n-    std::atomic<NodeId> nLastNodeId{0};\n-    unsigned int nPrevNodeCount{0};\n+    RecursiveMutex cs_sendProcessing;\n \n-    /**\n-     * Cache responses to addr requests to minimize privacy leak.\n-     * Attack example: scraping addrs in real-time may allow an attacker\n-     * to infer new connections of the victim by detecting new records\n-     * with fresh timestamps (per self-announcement).\n-     */\n-    struct CachedAddrResponse {\n-        std::vector<CAddress> m_addrs_response_cache;\n-        std::chrono::microseconds m_cache_entry_expiration{0};\n-    };\n+    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n \n+    std::atomic<int64_t> nLastSend{0};\n+    std::atomic<int64_t> nLastRecv{0};\n+    const int64_t nTimeConnected;\n+    std::atomic<int64_t> nTimeOffset{0};\n+    // Address of this peer\n+    const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n+    std::atomic<int> nVersion{0};\n+    RecursiveMutex cs_SubVer;\n     /**\n-     * Addr responses stored in different caches\n-     * per (network, local socket) prevent cross-network node identification.\n-     * If a node for example is multi-homed under Tor and IPv6,\n-     * a single cache (or no cache at all) would let an attacker\n-     * to easily detect that it is the same node by comparing responses.\n-     * Indexing by local socket prevents leakage when a node has multiple\n-     * listening addresses on the same network.\n-     *\n-     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n-     * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~196 KB. Every separate local socket may\n-     * add up to ~196 KB extra.\n+     * cleanSubVer is a sanitized string of the user agent byte array we read\n+     * from the wire. This cleaned string can safely be logged or displayed.\n      */\n-    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n-\n+    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n+    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n+    bool HasPermission(NetPermissionFlags permission) const {\n+        return NetPermissions::HasFlag(m_permissionFlags, permission);\n+    }\n+    bool fClient{false}; // set by version message\n+    bool m_limited_node{false}; //after BIP159, set by version message\n     /**\n-     * Services this instance offers.\n-     *\n-     * This data is replicated in each CNode instance we create during peer\n-     * connection (in ConnectNode()) under a member also called\n-     * nLocalServices.\n-     *\n-     * This data is not marked const, but after being set it should not\n-     * change. See the note in CNode::nLocalServices documentation.\n-     *\n-     * \\sa CNode::nLocalServices\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n      */\n-    ServiceFlags nLocalServices;\n-\n-    std::unique_ptr<CSemaphore> semOutbound;\n-    std::unique_ptr<CSemaphore> semAddnode;\n-    int nMaxConnections;\n+    std::atomic_bool m_wants_addrv2{false};\n+    std::atomic_bool fSuccessfullyConnected{false};\n+    // Setting fDisconnect to true will cause the node to be disconnected the\n+    // next time DisconnectNodes() runs\n+    std::atomic_bool fDisconnect{false};\n+    bool fSentAddr{false};\n+    CSemaphoreGrant grantOutbound;\n+    std::atomic<int> nRefCount{0};\n \n-    // How many full-relay (tx, block, addr) outbound peers we want\n-    int m_max_outbound_full_relay;\n+    const uint64_t nKeyedNetGroup;\n+    std::atomic_bool fPauseRecv{false};\n+    std::atomic_bool fPauseSend{false};\n \n-    // How many block-relay only outbound peers we want\n-    // We do not relay tx or addr messages with these peers\n-    int m_max_outbound_block_relay;\n+    bool IsOutboundOrBlockRelayConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+                return true;\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::ADDR_FETCH:\n+            case ConnectionType::FEELER:\n+                return false;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    int nMaxAddnode;\n-    int nMaxFeeler;\n-    int m_max_outbound;\n-    bool m_use_addrman_outgoing;\n-    CClientUIInterface* clientInterface;\n-    NetEventsInterface* m_msgproc;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* m_banman;\n+        assert(false);\n+    }\n \n-    /**\n-     * Addresses that were saved during the previous clean shutdown. We'll\n-     * attempt to make block-relay-only connections to them.\n-     */\n-    std::vector<CAddress> m_anchors;\n+    bool IsFullOutboundConn() const {\n+        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    }\n \n-    /** SipHasher seeds for deterministic randomness */\n-    const uint64_t nSeed0, nSeed1;\n+    bool IsManualConn() const {\n+        return m_conn_type == ConnectionType::MANUAL;\n+    }\n \n-    /** flag for waking the message processor. */\n-    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n+    bool IsBlockOnlyConn() const {\n+        return m_conn_type == ConnectionType::BLOCK_RELAY;\n+    }\n \n-    std::condition_variable condMsgProc;\n-    Mutex mutexMsgProc;\n-    std::atomic<bool> flagInterruptMsgProc{false};\n+    bool IsFeelerConn() const {\n+        return m_conn_type == ConnectionType::FEELER;\n+    }\n \n-    CThreadInterrupt interruptNet;\n+    bool IsAddrFetchConn() const {\n+        return m_conn_type == ConnectionType::ADDR_FETCH;\n+    }\n \n-    std::thread threadDNSAddressSeed;\n-    std::thread threadSocketHandler;\n-    std::thread threadOpenAddedConnections;\n-    std::thread threadOpenConnections;\n-    std::thread threadMessageHandler;\n+    bool IsInboundConn() const {\n+        return m_conn_type == ConnectionType::INBOUND;\n+    }\n \n-    /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of m_max_outbound_full_relay\n-     *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    /* Whether we send addr messages over this connection */\n+    bool RelayAddrsWithConn() const\n+    {\n+        // Don't relay addr messages to peers that we connect to as block-relay-only\n+        // peers (to prevent adversaries from inferring these links from addr\n+        // traffic).\n+        return m_conn_type != ConnectionType::BLOCK_RELAY;\n+    }\n \n-    /** flag for initiating extra block-relay-only peer connections.\n-     *  this should only be enabled after initial chain sync has occurred,\n-     *  as these connections are intended to be short-lived and low-bandwidth.\n-     */\n-    std::atomic_bool m_start_extra_block_relay_peers{false};\n+    bool ExpectServicesFromConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::FEELER:\n+                return false;\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::ADDR_FETCH:\n+                return true;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n+        assert(false);\n+    }\n \n     /**\n-     * A vector of -bind=<address>:<port>=onion arguments each of which is\n-     * an address and port that are designated for incoming Tor connections.\n+     * Get network the peer connected through.\n+     *\n+     * Returns Network::NET_ONION for *inbound* onion connections,\n+     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n+     * because it doesn't detect the former, and it's not the responsibility of\n+     * the CNetAddr class to know the actual network a peer is connected through.\n+     *\n+     * @return network the peer connected through.\n      */\n-    std::vector<CService> m_onion_binds;\n+    Network ConnectedThroughNetwork() const;\n \n-    friend struct CConnmanTest;\n-    friend struct ConnmanTestMsg;\n-};\n-void Discover();\n-void StartMapPort();\n-void InterruptMapPort();\n-void StopMapPort();\n-uint16_t GetListenPort();\n+protected:\n+    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n \n-/**\n- * Interface for message handling\n- */\n-class NetEventsInterface\n-{\n public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) = 0;\n-    virtual void InitializeNode(CNode* pnode) = 0;\n-    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n+    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_to{false};\n+    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+\n+    // flood relay\n+    std::vector<CAddress> vAddrToSend;\n+    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n+    bool fGetAddr{false};\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+\n+    struct TxRelay {\n+        mutable RecursiveMutex cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+\n+        mutable RecursiveMutex cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        std::chrono::microseconds nNextInvSend{0};\n \n-protected:\n-    /**\n-     * Protected destructor so that instances can only be deleted by derived classes.\n-     * If that restriction is no longer desired, this should be made public and virtual.\n-     */\n-    ~NetEventsInterface() = default;\n-};\n+        RecursiveMutex cs_feeFilter;\n+        // Minimum fee rate with which to filter inv's to this node\n+        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n+        CAmount lastSentFeeFilter{0};\n+        int64_t nextSendTimeFeeFilter{0};\n+    };\n \n-enum\n-{\n-    LOCAL_NONE,   // unknown\n-    LOCAL_IF,     // address a local interface listens on\n-    LOCAL_BIND,   // address explicit bound to\n-    LOCAL_UPNP,   // address reported by UPnP\n-    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n+    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n+    std::unique_ptr<TxRelay> m_tx_relay;\n \n-    LOCAL_MAX\n-};\n+    /** UNIX epoch time of the last block received from this peer that we had\n+     * not yet seen (e.g. not already received from another peer), that passed\n+     * preliminary validity checks and was saved to disk, even if we don't\n+     * connect the block or it eventually fails connection. Used as an inbound\n+     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastBlockTime{0};\n \n-bool IsPeerAddrLocalGood(CNode *pnode);\n-void AdvertiseLocal(CNode *pnode);\n+    /** UNIX epoch time of the last transaction received from this peer that we\n+     * had not yet seen (e.g. not already received from another peer) and that\n+     * was accepted into our mempool. Used as an inbound peer eviction criterium\n+     * in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastTXTime{0};\n \n-/**\n- * Mark a network as reachable or unreachable (no automatic connects to it)\n- * @note Networks are reachable by default\n- */\n-void SetReachable(enum Network net, bool reachable);\n-/** @returns true if the network is reachable, false otherwise */\n-bool IsReachable(enum Network net);\n-/** @returns true if the address is in a reachable network, false otherwise */\n-bool IsReachable(const CNetAddr& addr);\n+    // Ping time measurement:\n+    // The pong reply we're expecting, or 0 if no pong expected.\n+    std::atomic<uint64_t> nPingNonceSent{0};\n+    /** When the last ping was sent, or 0 if no ping was ever sent */\n+    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n+    // Last measured round-trip time.\n+    std::atomic<int64_t> nPingUsecTime{0};\n+    // Best measured round-trip time.\n+    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n+    // Whether a ping is requested.\n+    std::atomic<bool> fPingQueued{false};\n \n-bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n-bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n-void RemoveLocal(const CService& addr);\n-bool SeenLocal(const CService& addr);\n-bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n+    ~CNode();\n+    CNode(const CNode&) = delete;\n+    CNode& operator=(const CNode&) = delete;\n \n+private:\n+    const NodeId id;\n+    const uint64_t nLocalHostNonce;\n+    const ConnectionType m_conn_type;\n+    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n \n-extern bool fDiscover;\n-extern bool fListen;\n+    //! Services offered to this peer.\n+    //!\n+    //! This is supplied by the parent CConnman during peer connection\n+    //! (CConnman::ConnectNode()) from its attribute of the same name.\n+    //!\n+    //! This is const because there is no protocol defined for renegotiating\n+    //! services initially offered to a peer. The set of local services we\n+    //! offer should not change after initialization.\n+    //!\n+    //! An interesting example of this is NODE_NETWORK and initial block\n+    //! download: a node which starts up from scratch doesn't have any blocks\n+    //! to serve, but still advertises NODE_NETWORK because it will eventually\n+    //! fulfill this role after IBD completes. P2P code is written in such a\n+    //! way that it can gracefully handle peers who don't make good on their\n+    //! service advertisements.\n+    const ServiceFlags nLocalServices;\n \n-/** Subversion as sent to the P2P network in `version` messages */\n-extern std::string strSubVersion;\n+    NetPermissionFlags m_permissionFlags{ PF_NONE };\n+    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n-struct LocalServiceInfo {\n-    int nScore;\n-    int nPort;\n-};\n+    mutable RecursiveMutex cs_addrName;\n+    std::string addrName GUARDED_BY(cs_addrName);\n \n-extern RecursiveMutex cs_mapLocalHost;\n-extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n+    // Our address, as reported by the peer\n+    CService addrLocal GUARDED_BY(cs_addrLocal);\n+    mutable RecursiveMutex cs_addrLocal;\n \n-extern const std::string NET_MESSAGE_COMMAND_OTHER;\n-typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n+    const bool m_inbound_onion{false};\n \n-class CNodeStats\n-{\n public:\n-    NodeId nodeid;\n-    ServiceFlags nServices;\n-    bool fRelayTxes;\n-    int64_t nLastSend;\n-    int64_t nLastRecv;\n-    int64_t nLastTXTime;\n-    int64_t nLastBlockTime;\n-    int64_t nTimeConnected;\n-    int64_t nTimeOffset;\n-    std::string addrName;\n-    int nVersion;\n-    std::string cleanSubVer;\n-    bool fInbound;\n-    bool m_bip152_highbandwidth_to;\n-    bool m_bip152_highbandwidth_from;\n-    int m_starting_height;\n-    uint64_t nSendBytes;\n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    uint64_t nRecvBytes;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n-    NetPermissionFlags m_permissionFlags;\n-    int64_t m_ping_usec;\n-    int64_t m_ping_wait_usec;\n-    int64_t m_min_ping_usec;\n-    CAmount minFeeFilter;\n-    // Our address, as reported by the peer\n-    std::string addrLocal;\n-    // Address of this peer\n-    CAddress addr;\n-    // Bind address of our side of the connection\n-    CAddress addrBind;\n-    // Network the peer connected through\n-    Network m_network;\n-    uint32_t m_mapped_as;\n-    std::string m_conn_type_string;\n-};\n \n+    NodeId GetId() const {\n+        return id;\n+    }\n \n+    uint64_t GetLocalNonce() const {\n+        return nLocalHostNonce;\n+    }\n \n-/** Transport protocol agnostic message container.\n- * Ideally it should only contain receive time, payload,\n- * command and size.\n- */\n-class CNetMessage {\n-public:\n-    CDataStream m_recv;                  //!< received message data\n-    std::chrono::microseconds m_time{0}; //!< time of message receipt\n-    uint32_t m_message_size{0};          //!< size of the payload\n-    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n-    std::string m_command;\n+    int GetRefCount() const\n+    {\n+        assert(nRefCount >= 0);\n+        return nRefCount;\n+    }\n \n-    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n+    /**\n+     * Receive bytes from the buffer and deserialize them into messages.\n+     *\n+     * @param[in]   msg_bytes   The raw data\n+     * @param[out]  complete    Set True if at least one message has been\n+     *                          deserialized and is ready to be processed\n+     * @return  True if the peer should stay connected,\n+     *          False if the peer should be disconnected from.\n+     */\n+    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n \n-    void SetVersion(int nVersionIn)\n+    void SetCommonVersion(int greatest_common_version)\n     {\n-        m_recv.SetVersion(nVersionIn);\n+        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n+        m_greatest_common_version = greatest_common_version;\n+    }\n+    int GetCommonVersion() const\n+    {\n+        return m_greatest_common_version;\n     }\n-};\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (command & payload)\n- */\n-class TransportDeserializer {\n-public:\n-    // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n-    // decomposes a message from the context\n-    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n-    virtual ~TransportDeserializer() {}\n-};\n+    CService GetAddrLocal() const;\n+    //! May not be called more than once\n+    void SetAddrLocal(const CService& addrLocalIn);\n \n-class V1TransportDeserializer final : public TransportDeserializer\n-{\n-private:\n-    const CChainParams& m_chain_params;\n-    const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n+    CNode* AddRef()\n+    {\n+        nRefCount++;\n+        return this;\n+    }\n \n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n+    void Release()\n+    {\n+        nRefCount--;\n+    }\n \n-    void Reset() {\n-        vRecv.clear();\n-        hdrbuf.clear();\n-        hdrbuf.resize(24);\n-        in_data = false;\n-        nHdrPos = 0;\n-        nDataPos = 0;\n-        data_hash.SetNull();\n-        hasher.Reset();\n+\n+\n+    void AddAddressKnown(const CAddress& _addr)\n+    {\n+        assert(m_addr_known);\n+        m_addr_known->insert(_addr.GetKey());\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    /**\n+     * Whether the peer supports the address. For example, a peer that does not\n+     * implement BIP155 cannot receive Tor v3 addresses because it requires\n+     * ADDRv2 (BIP155) encoding.\n+     */\n+    bool IsAddrCompatible(const CAddress& addr) const\n     {\n-        Reset();\n+        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n     }\n \n-    bool Complete() const override\n+    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        // Known checking here is only to save space from duplicates.\n+        // SendMessages will filter it again for knowns that were added\n+        // after addresses were pushed.\n+        assert(m_addr_known);\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n+            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n+            } else {\n+                vAddrToSend.push_back(_addr);\n+            }\n+        }\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+\n+    void AddKnownTx(const uint256& hash)\n     {\n-        hdrbuf.SetVersion(nVersionIn);\n-        vRecv.SetVersion(nVersionIn);\n+        if (m_tx_relay != nullptr) {\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            m_tx_relay->filterInventoryKnown.insert(hash);\n+        }\n     }\n-    int Read(Span<const uint8_t>& msg_bytes) override\n+\n+    void PushTxInventory(const uint256& hash)\n     {\n-        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n-        if (ret < 0) {\n-            Reset();\n-        } else {\n-            msg_bytes = msg_bytes.subspan(ret);\n+        if (m_tx_relay == nullptr) return;\n+        LOCK(m_tx_relay->cs_tx_inventory);\n+        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n+            m_tx_relay->setInventoryTxToSend.insert(hash);\n         }\n-        return ret;\n     }\n-    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+\n+    void CloseSocketDisconnect();\n+\n+    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+\n+    ServiceFlags GetLocalServices() const\n+    {\n+        return nLocalServices;\n+    }\n+\n+    std::string GetAddrName() const;\n+    //! Sets the addrName only if it was not previously set\n+    void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    std::string ConnectionTypeAsString() const;\n+\n+    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n+    bool IsInboundOnion() const { return m_inbound_onion; }\n };\n \n-/** The TransportSerializer prepares messages for the network transport\n+/**\n+ * Interface for message handling\n  */\n-class TransportSerializer {\n+class NetEventsInterface\n+{\n public:\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n-    virtual ~TransportSerializer() {}\n-};\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n-class V1TransportSerializer  : public TransportSerializer {\n-public:\n-    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n };\n \n-/** Information about a peer */\n-class CNode\n+class CConnman\n {\n-    friend class CConnman;\n-    friend struct ConnmanTestMsg;\n-\n public:\n-    std::unique_ptr<TransportDeserializer> m_deserializer;\n-    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // socket\n-    std::atomic<ServiceFlags> nServices{NODE_NONE};\n-    SOCKET hSocket GUARDED_BY(cs_hSocket);\n-    /** Total size of all vSendMsg entries */\n-    size_t nSendSize GUARDED_BY(cs_vSend){0};\n-    /** Offset inside the first vSendMsg already sent */\n-    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n-    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n-    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n-    Mutex cs_vSend;\n-    Mutex cs_hSocket;\n-    Mutex cs_vRecv;\n+    enum NumConnections {\n+        CONNECTIONS_NONE = 0,\n+        CONNECTIONS_IN = (1U << 0),\n+        CONNECTIONS_OUT = (1U << 1),\n+        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n+    };\n \n-    RecursiveMutex cs_vProcessMsg;\n-    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n-    size_t nProcessQueueSize{0};\n+    struct Options\n+    {\n+        ServiceFlags nLocalServices = NODE_NONE;\n+        int nMaxConnections = 0;\n+        int m_max_outbound_full_relay = 0;\n+        int m_max_outbound_block_relay = 0;\n+        int nMaxAddnode = 0;\n+        int nMaxFeeler = 0;\n+        CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n+        BanMan* m_banman = nullptr;\n+        unsigned int nSendBufferMaxSize = 0;\n+        unsigned int nReceiveFloodSize = 0;\n+        uint64_t nMaxOutboundLimit = 0;\n+        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+        std::vector<NetWhitebindPermissions> vWhiteBinds;\n+        std::vector<CService> vBinds;\n+        std::vector<CService> onion_binds;\n+        bool m_use_addrman_outgoing = true;\n+        std::vector<std::string> m_specified_outgoing;\n+        std::vector<std::string> m_added_nodes;\n+        std::vector<bool> m_asmap;\n+    };\n \n-    RecursiveMutex cs_sendProcessing;\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n+        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n+        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n+        clientInterface = connOptions.uiInterface;\n+        m_banman = connOptions.m_banman;\n+        m_msgproc = connOptions.m_msgproc;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n+        {\n+            LOCK(cs_totalBytesSent);\n+            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        }\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+        {\n+            LOCK(cs_vAddedNodes);\n+            vAddedNodes = connOptions.m_added_nodes;\n+        }\n+        m_onion_binds = connOptions.onion_binds;\n+    }\n \n-    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n+    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n+    ~CConnman();\n+    bool Start(CScheduler& scheduler, const Options& options);\n \n-    std::atomic<int64_t> nLastSend{0};\n-    std::atomic<int64_t> nLastRecv{0};\n-    const int64_t nTimeConnected;\n-    std::atomic<int64_t> nTimeOffset{0};\n-    // Address of this peer\n-    const CAddress addr;\n-    // Bind address of our side of the connection\n-    const CAddress addrBind;\n-    std::atomic<int> nVersion{0};\n-    RecursiveMutex cs_SubVer;\n-    /**\n-     * cleanSubVer is a sanitized string of the user agent byte array we read\n-     * from the wire. This cleaned string can safely be logged or displayed.\n-     */\n-    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n-    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n-    bool HasPermission(NetPermissionFlags permission) const {\n-        return NetPermissions::HasFlag(m_permissionFlags, permission);\n-    }\n-    bool fClient{false}; // set by version message\n-    bool m_limited_node{false}; //after BIP159, set by version message\n-    /**\n-     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n-     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n-     */\n-    std::atomic_bool m_wants_addrv2{false};\n-    std::atomic_bool fSuccessfullyConnected{false};\n-    // Setting fDisconnect to true will cause the node to be disconnected the\n-    // next time DisconnectNodes() runs\n-    std::atomic_bool fDisconnect{false};\n-    bool fSentAddr{false};\n-    CSemaphoreGrant grantOutbound;\n-    std::atomic<int> nRefCount{0};\n+    void StopThreads();\n+    void StopNodes();\n+    void Stop()\n+    {\n+        StopThreads();\n+        StopNodes();\n+    };\n+\n+    void Interrupt();\n+    bool GetNetworkActive() const { return fNetworkActive; };\n+    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n+    void SetNetworkActive(bool active);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n+    bool CheckIncomingNonce(uint64_t nonce);\n+\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n+\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    void ForEachNode(const NodeFn& func) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    const uint64_t nKeyedNetGroup;\n-    std::atomic_bool fPauseRecv{false};\n-    std::atomic_bool fPauseSend{false};\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    bool IsOutboundOrBlockRelayConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-                return true;\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::ADDR_FETCH:\n-            case ConnectionType::FEELER:\n-                return false;\n-        } // no default case, so the compiler can warn about missing cases\n+    // Addrman functions\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void MarkAddressGood(const CAddress& addr);\n+    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    /**\n+     * Cache is used to minimize topology leaks, so it should\n+     * be used for all non-trusted calls, for example, p2p.\n+     * A non-malicious call (from RPC or a peer with addr permission) should\n+     * call the function without a parameter to avoid using the cache.\n+     */\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n \n-        assert(false);\n-    }\n+    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n \n-    bool IsFullOutboundConn() const {\n-        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    void StartExtraBlockRelayPeers() {\n+        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n+        m_start_extra_block_relay_peers = true;\n     }\n \n-    bool IsManualConn() const {\n-        return m_conn_type == ConnectionType::MANUAL;\n-    }\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraFullOutboundCount();\n+    // Count the number of block-relay-only peers we have over our limit.\n+    int GetExtraBlockRelayCount();\n \n-    bool IsBlockOnlyConn() const {\n-        return m_conn_type == ConnectionType::BLOCK_RELAY;\n-    }\n+    bool AddNode(const std::string& node);\n+    bool RemoveAddedNode(const std::string& node);\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    bool IsFeelerConn() const {\n-        return m_conn_type == ConnectionType::FEELER;\n-    }\n+    size_t GetNodeCount(NumConnections num);\n+    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    bool DisconnectNode(const std::string& node);\n+    bool DisconnectNode(const CSubNet& subnet);\n+    bool DisconnectNode(const CNetAddr& addr);\n+    bool DisconnectNode(NodeId id);\n \n-    bool IsAddrFetchConn() const {\n-        return m_conn_type == ConnectionType::ADDR_FETCH;\n-    }\n+    //! Used to convey which local services we are offering peers during node\n+    //! connection.\n+    //!\n+    //! The data returned by this is used in CNode construction,\n+    //! which is used to advertise which services we are offering\n+    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n+    ServiceFlags GetLocalServices() const;\n \n-    bool IsInboundConn() const {\n-        return m_conn_type == ConnectionType::INBOUND;\n-    }\n+    uint64_t GetMaxOutboundTarget();\n+    std::chrono::seconds GetMaxOutboundTimeframe();\n \n-    /* Whether we send addr messages over this connection */\n-    bool RelayAddrsWithConn() const\n-    {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n-        // peers (to prevent adversaries from inferring these links from addr\n-        // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n-    }\n+    //! check if the outbound target is reached\n+    //! if param historicalBlockServingLimit is set true, the function will\n+    //! response true if the limit for serving historical blocks has been reached\n+    bool OutboundTargetReached(bool historicalBlockServingLimit);\n \n-    bool ExpectServicesFromConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::FEELER:\n-                return false;\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-            case ConnectionType::ADDR_FETCH:\n-                return true;\n-        } // no default case, so the compiler can warn about missing cases\n+    //! response the bytes left in the current max outbound cycle\n+    //! in case of no limit, it will always response 0\n+    uint64_t GetOutboundTargetBytesLeft();\n \n-        assert(false);\n-    }\n+    //! returns the time left in the current max outbound cycle\n+    //! in case of no limit, it will always return 0\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n \n-    /**\n-     * Get network the peer connected through.\n-     *\n-     * Returns Network::NET_ONION for *inbound* onion connections,\n-     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n-     * because it doesn't detect the former, and it's not the responsibility of\n-     * the CNetAddr class to know the actual network a peer is connected through.\n-     *\n-     * @return network the peer connected through.\n-     */\n-    Network ConnectedThroughNetwork() const;\n+    uint64_t GetTotalBytesRecv();\n+    uint64_t GetTotalBytesSent();\n \n-protected:\n-    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n+    /** Get a unique deterministic randomizer. */\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-public:\n-    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_to{false};\n-    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+    unsigned int GetReceiveFloodSize() const;\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n-    bool fGetAddr{false};\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    void WakeMessageHandler();\n \n-    struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n+        Works assuming that a single interval is used.\n+        Variable intervals will result in privacy decrease.\n+    */\n+    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n-        // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n-        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n+    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n-        RecursiveMutex cs_feeFilter;\n-        // Minimum fee rate with which to filter inv's to this node\n-        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n-        CAmount lastSentFeeFilter{0};\n-        int64_t nextSendTimeFeeFilter{0};\n+private:\n+    struct ListenSocket {\n+    public:\n+        SOCKET socket;\n+        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n+        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n+    private:\n+        NetPermissionFlags m_permissions;\n     };\n \n-    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n-    std::unique_ptr<TxRelay> m_tx_relay;\n+    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n+    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n+    bool InitBinds(\n+        const std::vector<CService>& binds,\n+        const std::vector<NetWhitebindPermissions>& whiteBinds,\n+        const std::vector<CService>& onion_binds);\n \n-    /** UNIX epoch time of the last block received from this peer that we had\n-     * not yet seen (e.g. not already received from another peer), that passed\n-     * preliminary validity checks and was saved to disk, even if we don't\n-     * connect the block or it eventually fails connection. Used as an inbound\n-     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastBlockTime{0};\n+    void ThreadOpenAddedConnections();\n+    void AddAddrFetch(const std::string& strDest);\n+    void ProcessAddrFetch();\n+    void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadMessageHandler();\n+    void AcceptConnection(const ListenSocket& hListenSocket);\n+    void DisconnectNodes();\n+    void NotifyNumConnectionsChanged();\n+    void InactivityCheck(CNode *pnode);\n+    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketHandler();\n+    void ThreadSocketHandler();\n+    void ThreadDNSAddressSeed();\n \n-    /** UNIX epoch time of the last transaction received from this peer that we\n-     * had not yet seen (e.g. not already received from another peer) and that\n-     * was accepted into our mempool. Used as an inbound peer eviction criterium\n-     * in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastTXTime{0};\n+    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent{0};\n-    /** When the last ping was sent, or 0 if no ping was ever sent */\n-    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n-    // Last measured round-trip time.\n-    std::atomic<int64_t> nPingUsecTime{0};\n-    // Best measured round-trip time.\n-    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued{false};\n+    CNode* FindNode(const CNetAddr& ip);\n+    CNode* FindNode(const CSubNet& subNet);\n+    CNode* FindNode(const std::string& addrName);\n+    CNode* FindNode(const CService& addr);\n+\n+    /**\n+     * Determine whether we're already connected to a given address, in order to\n+     * avoid initiating duplicate connections.\n+     */\n+    bool AlreadyConnectedToAddress(const CAddress& addr);\n+\n+    bool AttemptToEvictConnection();\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n+    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n+\n+    void DeleteNode(CNode* pnode);\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n-    ~CNode();\n-    CNode(const CNode&) = delete;\n-    CNode& operator=(const CNode&) = delete;\n+    NodeId GetNewNodeId();\n \n-private:\n-    const NodeId id;\n-    const uint64_t nLocalHostNonce;\n-    const ConnectionType m_conn_type;\n-    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n+    size_t SocketSendData(CNode& node) const EXCLUSIVE_LOCKS_REQUIRED(node.cs_vSend);\n+    void DumpAddresses();\n \n-    //! Services offered to this peer.\n-    //!\n-    //! This is supplied by the parent CConnman during peer connection\n-    //! (CConnman::ConnectNode()) from its attribute of the same name.\n-    //!\n-    //! This is const because there is no protocol defined for renegotiating\n-    //! services initially offered to a peer. The set of local services we\n-    //! offer should not change after initialization.\n-    //!\n-    //! An interesting example of this is NODE_NETWORK and initial block\n-    //! download: a node which starts up from scratch doesn't have any blocks\n-    //! to serve, but still advertises NODE_NETWORK because it will eventually\n-    //! fulfill this role after IBD completes. P2P code is written in such a\n-    //! way that it can gracefully handle peers who don't make good on their\n-    //! service advertisements.\n-    const ServiceFlags nLocalServices;\n+    // Network stats\n+    void RecordBytesRecv(uint64_t bytes);\n+    void RecordBytesSent(uint64_t bytes);\n \n-    NetPermissionFlags m_permissionFlags{ PF_NONE };\n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n+    /**\n+     * Return vector of current BLOCK_RELAY peers.\n+     */\n+    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n \n-    mutable RecursiveMutex cs_addrName;\n-    std::string addrName GUARDED_BY(cs_addrName);\n+    // Whether the node should be passed out in ForEach* callbacks\n+    static bool NodeFullyConnected(const CNode* pnode);\n \n-    // Our address, as reported by the peer\n-    CService addrLocal GUARDED_BY(cs_addrLocal);\n-    mutable RecursiveMutex cs_addrLocal;\n+    // Network usage totals\n+    RecursiveMutex cs_totalBytesRecv;\n+    RecursiveMutex cs_totalBytesSent;\n+    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n+    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n-    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n-    const bool m_inbound_onion{false};\n+    // outbound limit & stats\n+    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n+    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n+    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n \n-public:\n+    // P2P timeout in seconds\n+    int64_t m_peer_connect_timeout;\n \n-    NodeId GetId() const {\n-        return id;\n-    }\n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n \n-    uint64_t GetLocalNonce() const {\n-        return nLocalHostNonce;\n-    }\n+    unsigned int nSendBufferMaxSize{0};\n+    unsigned int nReceiveFloodSize{0};\n \n-    int GetRefCount() const\n-    {\n-        assert(nRefCount >= 0);\n-        return nRefCount;\n-    }\n+    std::vector<ListenSocket> vhListenSocket;\n+    std::atomic<bool> fNetworkActive{true};\n+    bool fAddressesInitialized{false};\n+    CAddrMan addrman;\n+    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n+    RecursiveMutex m_addr_fetches_mutex;\n+    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n+    RecursiveMutex cs_vAddedNodes;\n+    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n+    std::list<CNode*> vNodesDisconnected;\n+    mutable RecursiveMutex cs_vNodes;\n+    std::atomic<NodeId> nLastNodeId{0};\n+    unsigned int nPrevNodeCount{0};\n \n     /**\n-     * Receive bytes from the buffer and deserialize them into messages.\n-     *\n-     * @param[in]   msg_bytes   The raw data\n-     * @param[out]  complete    Set True if at least one message has been\n-     *                          deserialized and is ready to be processed\n-     * @return  True if the peer should stay connected,\n-     *          False if the peer should be disconnected from.\n+     * Cache responses to addr requests to minimize privacy leak.\n+     * Attack example: scraping addrs in real-time may allow an attacker\n+     * to infer new connections of the victim by detecting new records\n+     * with fresh timestamps (per self-announcement).\n      */\n-    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n-\n-    void SetCommonVersion(int greatest_common_version)\n-    {\n-        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n-        m_greatest_common_version = greatest_common_version;\n-    }\n-    int GetCommonVersion() const\n-    {\n-        return m_greatest_common_version;\n-    }\n+    struct CachedAddrResponse {\n+        std::vector<CAddress> m_addrs_response_cache;\n+        std::chrono::microseconds m_cache_entry_expiration{0};\n+    };\n \n-    CService GetAddrLocal() const;\n-    //! May not be called more than once\n-    void SetAddrLocal(const CService& addrLocalIn);\n+    /**\n+     * Addr responses stored in different caches\n+     * per (network, local socket) prevent cross-network node identification.\n+     * If a node for example is multi-homed under Tor and IPv6,\n+     * a single cache (or no cache at all) would let an attacker\n+     * to easily detect that it is the same node by comparing responses.\n+     * Indexing by local socket prevents leakage when a node has multiple\n+     * listening addresses on the same network.\n+     *\n+     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n+     * distinct Network (up to 5) we have/had an inbound peer from,\n+     * resulting in at most ~196 KB. Every separate local socket may\n+     * add up to ~196 KB extra.\n+     */\n+    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n \n-    CNode* AddRef()\n-    {\n-        nRefCount++;\n-        return this;\n-    }\n+    /**\n+     * Services this instance offers.\n+     *\n+     * This data is replicated in each CNode instance we create during peer\n+     * connection (in ConnectNode()) under a member also called\n+     * nLocalServices.\n+     *\n+     * This data is not marked const, but after being set it should not\n+     * change. See the note in CNode::nLocalServices documentation.\n+     *\n+     * \\sa CNode::nLocalServices\n+     */\n+    ServiceFlags nLocalServices;\n \n-    void Release()\n-    {\n-        nRefCount--;\n-    }\n+    std::unique_ptr<CSemaphore> semOutbound;\n+    std::unique_ptr<CSemaphore> semAddnode;\n+    int nMaxConnections;\n \n+    // How many full-relay (tx, block, addr) outbound peers we want\n+    int m_max_outbound_full_relay;\n \n+    // How many block-relay only outbound peers we want\n+    // We do not relay tx or addr messages with these peers\n+    int m_max_outbound_block_relay;\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        assert(m_addr_known);\n-        m_addr_known->insert(_addr.GetKey());\n-    }\n+    int nMaxAddnode;\n+    int nMaxFeeler;\n+    int m_max_outbound;\n+    bool m_use_addrman_outgoing;\n+    CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* m_banman;\n \n     /**\n-     * Whether the peer supports the address. For example, a peer that does not\n-     * implement BIP155 cannot receive Tor v3 addresses because it requires\n-     * ADDRv2 (BIP155) encoding.\n+     * Addresses that were saved during the previous clean shutdown. We'll\n+     * attempt to make block-relay-only connections to them.\n      */\n-    bool IsAddrCompatible(const CAddress& addr) const\n-    {\n-        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n-    }\n+    std::vector<CAddress> m_anchors;\n \n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n-    {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n-        }\n-    }\n+    /** SipHasher seeds for deterministic randomness */\n+    const uint64_t nSeed0, nSeed1;\n \n+    /** flag for waking the message processor. */\n+    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n \n-    void AddKnownTx(const uint256& hash)\n-    {\n-        if (m_tx_relay != nullptr) {\n-            LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n-        }\n-    }\n+    std::condition_variable condMsgProc;\n+    Mutex mutexMsgProc;\n+    std::atomic<bool> flagInterruptMsgProc{false};\n \n-    void PushTxInventory(const uint256& hash)\n-    {\n-        if (m_tx_relay == nullptr) return;\n-        LOCK(m_tx_relay->cs_tx_inventory);\n-        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n-        }\n-    }\n+    CThreadInterrupt interruptNet;\n \n-    void CloseSocketDisconnect();\n+    std::thread threadDNSAddressSeed;\n+    std::thread threadSocketHandler;\n+    std::thread threadOpenAddedConnections;\n+    std::thread threadOpenConnections;\n+    std::thread threadMessageHandler;\n \n-    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of m_max_outbound_full_relay\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n \n-    ServiceFlags GetLocalServices() const\n-    {\n-        return nLocalServices;\n-    }\n+    /** flag for initiating extra block-relay-only peer connections.\n+     *  this should only be enabled after initial chain sync has occurred,\n+     *  as these connections are intended to be short-lived and low-bandwidth.\n+     */\n+    std::atomic_bool m_start_extra_block_relay_peers{false};\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n+    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n \n-    std::string ConnectionTypeAsString() const;\n+    /**\n+     * A vector of -bind=<address>:<port>=onion arguments each of which is\n+     * an address and port that are designated for incoming Tor connections.\n+     */\n+    std::vector<CService> m_onion_binds;\n \n-    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n-    bool IsInboundOnion() const { return m_inbound_onion; }\n+    friend struct CConnmanTest;\n+    friend struct ConnmanTestMsg;\n };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r552621025",
      "id" : 552621025,
      "line" : 1216,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYyMTAyNQ==",
      "original_commit_id" : "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "original_line" : 1216,
      "original_position" : 1906,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 1906,
      "pull_request_review_id" : 562714005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-07T08:42:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/552621025",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "created_at" : "2021-01-07T01:07:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755818506",
      "id" : 755818506,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NTgxODUwNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-07T01:07:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755818506",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, should be trivial to re-ACK with git range-diff or from scratch",
      "created_at" : "2021-01-07T08:39:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755971118",
      "id" : 755971118,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NTk3MTExOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-07T08:39:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755971118",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r553182212"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/553182212"
         }
      },
      "author_association" : "MEMBER",
      "body" : "thanks, done",
      "commit_id" : "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "created_at" : "2021-01-07T08:42:52Z",
      "diff_hunk" : "@@ -180,1041 +180,1040 @@ enum class ConnectionType {\n     ADDR_FETCH,\n };\n \n-class NetEventsInterface;\n-class CConnman\n-{\n-public:\n-\n-    enum NumConnections {\n-        CONNECTIONS_NONE = 0,\n-        CONNECTIONS_IN = (1U << 0),\n-        CONNECTIONS_OUT = (1U << 1),\n-        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n-    };\n-\n-    struct Options\n-    {\n-        ServiceFlags nLocalServices = NODE_NONE;\n-        int nMaxConnections = 0;\n-        int m_max_outbound_full_relay = 0;\n-        int m_max_outbound_block_relay = 0;\n-        int nMaxAddnode = 0;\n-        int nMaxFeeler = 0;\n-        CClientUIInterface* uiInterface = nullptr;\n-        NetEventsInterface* m_msgproc = nullptr;\n-        BanMan* m_banman = nullptr;\n-        unsigned int nSendBufferMaxSize = 0;\n-        unsigned int nReceiveFloodSize = 0;\n-        uint64_t nMaxOutboundLimit = 0;\n-        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n-        std::vector<std::string> vSeedNodes;\n-        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n-        std::vector<NetWhitebindPermissions> vWhiteBinds;\n-        std::vector<CService> vBinds;\n-        std::vector<CService> onion_binds;\n-        bool m_use_addrman_outgoing = true;\n-        std::vector<std::string> m_specified_outgoing;\n-        std::vector<std::string> m_added_nodes;\n-        std::vector<bool> m_asmap;\n-    };\n-\n-    void Init(const Options& connOptions) {\n-        nLocalServices = connOptions.nLocalServices;\n-        nMaxConnections = connOptions.nMaxConnections;\n-        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n-        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n-        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n-        nMaxAddnode = connOptions.nMaxAddnode;\n-        nMaxFeeler = connOptions.nMaxFeeler;\n-        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n-        clientInterface = connOptions.uiInterface;\n-        m_banman = connOptions.m_banman;\n-        m_msgproc = connOptions.m_msgproc;\n-        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n-        {\n-            LOCK(cs_totalBytesSent);\n-            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-        }\n-        vWhitelistedRange = connOptions.vWhitelistedRange;\n-        {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n-        }\n-        m_onion_binds = connOptions.onion_binds;\n-    }\n-\n-    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n-    ~CConnman();\n-    bool Start(CScheduler& scheduler, const Options& options);\n-\n-    void StopThreads();\n-    void StopNodes();\n-    void Stop()\n-    {\n-        StopThreads();\n-        StopNodes();\n-    };\n-\n-    void Interrupt();\n-    bool GetNetworkActive() const { return fNetworkActive; };\n-    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n-    void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n-    bool CheckIncomingNonce(uint64_t nonce);\n-\n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n-\n-    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n-\n-    using NodeFn = std::function<void(CNode*)>;\n-    void ForEachNode(const NodeFn& func)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    void ForEachNode(const NodeFn& func) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+void Discover();\n+void StartMapPort();\n+void InterruptMapPort();\n+void StopMapPort();\n+uint16_t GetListenPort();\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+enum\n+{\n+    LOCAL_NONE,   // unknown\n+    LOCAL_IF,     // address a local interface listens on\n+    LOCAL_BIND,   // address explicit bound to\n+    LOCAL_UPNP,   // address reported by UPnP\n+    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n \n-    // Addrman functions\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n-    /**\n-     * Cache is used to minimize topology leaks, so it should\n-     * be used for all non-trusted calls, for example, p2p.\n-     * A non-malicious call (from RPC or a peer with addr permission) should\n-     * call the function without a parameter to avoid using the cache.\n-     */\n-    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n+    LOCAL_MAX\n+};\n \n-    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n-    // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+bool IsPeerAddrLocalGood(CNode *pnode);\n+void AdvertiseLocal(CNode *pnode);\n \n-    void StartExtraBlockRelayPeers() {\n-        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n-        m_start_extra_block_relay_peers = true;\n-    }\n+/**\n+ * Mark a network as reachable or unreachable (no automatic connects to it)\n+ * @note Networks are reachable by default\n+ */\n+void SetReachable(enum Network net, bool reachable);\n+/** @returns true if the network is reachable, false otherwise */\n+bool IsReachable(enum Network net);\n+/** @returns true if the address is in a reachable network, false otherwise */\n+bool IsReachable(const CNetAddr& addr);\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n-    // to false, we may have extra peers that we wish to disconnect). This may\n-    // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n-    // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n-    // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n+bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+void RemoveLocal(const CService& addr);\n+bool SeenLocal(const CService& addr);\n+bool IsLocal(const CService& addr);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n+CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n \n-    bool AddNode(const std::string& node);\n-    bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    size_t GetNodeCount(NumConnections num);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n-    bool DisconnectNode(const std::string& node);\n-    bool DisconnectNode(const CSubNet& subnet);\n-    bool DisconnectNode(const CNetAddr& addr);\n-    bool DisconnectNode(NodeId id);\n+extern bool fDiscover;\n+extern bool fListen;\n \n-    //! Used to convey which local services we are offering peers during node\n-    //! connection.\n-    //!\n-    //! The data returned by this is used in CNode construction,\n-    //! which is used to advertise which services we are offering\n-    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n-    ServiceFlags GetLocalServices() const;\n+/** Subversion as sent to the P2P network in `version` messages */\n+extern std::string strSubVersion;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+struct LocalServiceInfo {\n+    int nScore;\n+    int nPort;\n+};\n \n-    //! check if the outbound target is reached\n-    //! if param historicalBlockServingLimit is set true, the function will\n-    //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+extern RecursiveMutex cs_mapLocalHost;\n+extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n \n-    //! response the bytes left in the current max outbound cycle\n-    //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+extern const std::string NET_MESSAGE_COMMAND_OTHER;\n+typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n \n-    //! returns the time left in the current max outbound cycle\n-    //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+class CNodeStats\n+{\n+public:\n+    NodeId nodeid;\n+    ServiceFlags nServices;\n+    bool fRelayTxes;\n+    int64_t nLastSend;\n+    int64_t nLastRecv;\n+    int64_t nLastTXTime;\n+    int64_t nLastBlockTime;\n+    int64_t nTimeConnected;\n+    int64_t nTimeOffset;\n+    std::string addrName;\n+    int nVersion;\n+    std::string cleanSubVer;\n+    bool fInbound;\n+    bool m_bip152_highbandwidth_to;\n+    bool m_bip152_highbandwidth_from;\n+    int m_starting_height;\n+    uint64_t nSendBytes;\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    uint64_t nRecvBytes;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    NetPermissionFlags m_permissionFlags;\n+    int64_t m_ping_usec;\n+    int64_t m_ping_wait_usec;\n+    int64_t m_min_ping_usec;\n+    CAmount minFeeFilter;\n+    // Our address, as reported by the peer\n+    std::string addrLocal;\n+    // Address of this peer\n+    CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n+    // Network the peer connected through\n+    Network m_network;\n+    uint32_t m_mapped_as;\n+    std::string m_conn_type_string;\n+};\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n \n-    /** Get a unique deterministic randomizer. */\n-    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-    unsigned int GetReceiveFloodSize() const;\n+/** Transport protocol agnostic message container.\n+ * Ideally it should only contain receive time, payload,\n+ * command and size.\n+ */\n+class CNetMessage {\n+public:\n+    CDataStream m_recv;                  //!< received message data\n+    std::chrono::microseconds m_time{0}; //!< time of message receipt\n+    uint32_t m_message_size{0};          //!< size of the payload\n+    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n+    std::string m_command;\n \n-    void WakeMessageHandler();\n+    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n \n-    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n-        Works assuming that a single interval is used.\n-        Variable intervals will result in privacy decrease.\n-    */\n-    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n+    void SetVersion(int nVersionIn)\n+    {\n+        m_recv.SetVersion(nVersionIn);\n+    }\n+};\n \n-    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n+/** The TransportDeserializer takes care of holding and deserializing the\n+ * network receive buffer. It can deserialize the network buffer into a\n+ * transport protocol agnostic CNetMessage (command & payload)\n+ */\n+class TransportDeserializer {\n+public:\n+    // returns true if the current deserialization is complete\n+    virtual bool Complete() const = 0;\n+    // set the serialization context version\n+    virtual void SetVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer */\n+    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    // decomposes a message from the context\n+    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n+    virtual ~TransportDeserializer() {}\n+};\n \n+class V1TransportDeserializer final : public TransportDeserializer\n+{\n private:\n-    struct ListenSocket {\n-    public:\n-        SOCKET socket;\n-        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n-        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n-    private:\n-        NetPermissionFlags m_permissions;\n-    };\n-\n-    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n-    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n-    bool InitBinds(\n-        const std::vector<CService>& binds,\n-        const std::vector<NetWhitebindPermissions>& whiteBinds,\n-        const std::vector<CService>& onion_binds);\n-\n-    void ThreadOpenAddedConnections();\n-    void AddAddrFetch(const std::string& strDest);\n-    void ProcessAddrFetch();\n-    void ThreadOpenConnections(std::vector<std::string> connect);\n-    void ThreadMessageHandler();\n-    void AcceptConnection(const ListenSocket& hListenSocket);\n-    void DisconnectNodes();\n-    void NotifyNumConnectionsChanged();\n-    void InactivityCheck(CNode *pnode);\n-    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketHandler();\n-    void ThreadSocketHandler();\n-    void ThreadDNSAddressSeed();\n-\n-    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n-\n-    CNode* FindNode(const CNetAddr& ip);\n-    CNode* FindNode(const CSubNet& subNet);\n-    CNode* FindNode(const std::string& addrName);\n-    CNode* FindNode(const CService& addr);\n-\n-    /**\n-     * Determine whether we're already connected to a given address, in order to\n-     * avoid initiating duplicate connections.\n-     */\n-    bool AlreadyConnectedToAddress(const CAddress& addr);\n-\n-    bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n-    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n-\n-    void DeleteNode(CNode* pnode);\n+    const CChainParams& m_chain_params;\n+    const NodeId m_node_id; // Only for logging\n+    mutable CHash256 hasher;\n+    mutable uint256 data_hash;\n+    bool in_data;                   // parsing header (false) or data (true)\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    CDataStream vRecv;              // received message data\n+    unsigned int nHdrPos;\n+    unsigned int nDataPos;\n \n-    NodeId GetNewNodeId();\n+    const uint256& GetMessageHash() const;\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n \n-    size_t SocketSendData(CNode *pnode) const;\n-    void DumpAddresses();\n+    void Reset() {\n+        vRecv.clear();\n+        hdrbuf.clear();\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+        data_hash.SetNull();\n+        hasher.Reset();\n+    }\n \n-    // Network stats\n-    void RecordBytesRecv(uint64_t bytes);\n-    void RecordBytesSent(uint64_t bytes);\n+public:\n+    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n+        : m_chain_params(chain_params),\n+          m_node_id(node_id),\n+          hdrbuf(nTypeIn, nVersionIn),\n+          vRecv(nTypeIn, nVersionIn)\n+    {\n+        Reset();\n+    }\n \n-    /**\n-     * Return vector of current BLOCK_RELAY peers.\n-     */\n-    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n+    bool Complete() const override\n+    {\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+};\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n+/** The TransportSerializer prepares messages for the network transport\n+ */\n+class TransportSerializer {\n+public:\n+    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n+    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n+    virtual ~TransportSerializer() {}\n+};\n \n-    // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n-    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n+class V1TransportSerializer  : public TransportSerializer {\n+public:\n+    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n \n-    // outbound limit & stats\n-    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n-    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n-    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n+/** Information about a peer */\n+class CNode\n+{\n+    friend class CConnman;\n+    friend struct ConnmanTestMsg;\n \n-    // P2P timeout in seconds\n-    int64_t m_peer_connect_timeout;\n+public:\n+    std::unique_ptr<TransportDeserializer> m_deserializer;\n+    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // Whitelisted ranges. Any node connecting from these is automatically\n-    // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+    // socket\n+    std::atomic<ServiceFlags> nServices{NODE_NONE};\n+    SOCKET hSocket GUARDED_BY(cs_hSocket);\n+    /** Total size of all vSendMsg entries */\n+    size_t nSendSize GUARDED_BY(cs_vSend){0};\n+    /** Offset inside the first vSendMsg already sent */\n+    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n+    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n+    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n+    Mutex cs_vSend;\n+    Mutex cs_hSocket;\n+    Mutex cs_vRecv;\n \n-    unsigned int nSendBufferMaxSize{0};\n-    unsigned int nReceiveFloodSize{0};\n+    RecursiveMutex cs_vProcessMsg;\n+    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n+    size_t nProcessQueueSize{0};\n \n-    std::vector<ListenSocket> vhListenSocket;\n-    std::atomic<bool> fNetworkActive{true};\n-    bool fAddressesInitialized{false};\n-    CAddrMan addrman;\n-    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n-    RecursiveMutex m_addr_fetches_mutex;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n-    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable RecursiveMutex cs_vNodes;\n-    std::atomic<NodeId> nLastNodeId{0};\n-    unsigned int nPrevNodeCount{0};\n+    RecursiveMutex cs_sendProcessing;\n \n-    /**\n-     * Cache responses to addr requests to minimize privacy leak.\n-     * Attack example: scraping addrs in real-time may allow an attacker\n-     * to infer new connections of the victim by detecting new records\n-     * with fresh timestamps (per self-announcement).\n-     */\n-    struct CachedAddrResponse {\n-        std::vector<CAddress> m_addrs_response_cache;\n-        std::chrono::microseconds m_cache_entry_expiration{0};\n-    };\n+    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n \n+    std::atomic<int64_t> nLastSend{0};\n+    std::atomic<int64_t> nLastRecv{0};\n+    const int64_t nTimeConnected;\n+    std::atomic<int64_t> nTimeOffset{0};\n+    // Address of this peer\n+    const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n+    std::atomic<int> nVersion{0};\n+    RecursiveMutex cs_SubVer;\n     /**\n-     * Addr responses stored in different caches\n-     * per (network, local socket) prevent cross-network node identification.\n-     * If a node for example is multi-homed under Tor and IPv6,\n-     * a single cache (or no cache at all) would let an attacker\n-     * to easily detect that it is the same node by comparing responses.\n-     * Indexing by local socket prevents leakage when a node has multiple\n-     * listening addresses on the same network.\n-     *\n-     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n-     * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~196 KB. Every separate local socket may\n-     * add up to ~196 KB extra.\n+     * cleanSubVer is a sanitized string of the user agent byte array we read\n+     * from the wire. This cleaned string can safely be logged or displayed.\n      */\n-    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n-\n+    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n+    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n+    bool HasPermission(NetPermissionFlags permission) const {\n+        return NetPermissions::HasFlag(m_permissionFlags, permission);\n+    }\n+    bool fClient{false}; // set by version message\n+    bool m_limited_node{false}; //after BIP159, set by version message\n     /**\n-     * Services this instance offers.\n-     *\n-     * This data is replicated in each CNode instance we create during peer\n-     * connection (in ConnectNode()) under a member also called\n-     * nLocalServices.\n-     *\n-     * This data is not marked const, but after being set it should not\n-     * change. See the note in CNode::nLocalServices documentation.\n-     *\n-     * \\sa CNode::nLocalServices\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n      */\n-    ServiceFlags nLocalServices;\n-\n-    std::unique_ptr<CSemaphore> semOutbound;\n-    std::unique_ptr<CSemaphore> semAddnode;\n-    int nMaxConnections;\n+    std::atomic_bool m_wants_addrv2{false};\n+    std::atomic_bool fSuccessfullyConnected{false};\n+    // Setting fDisconnect to true will cause the node to be disconnected the\n+    // next time DisconnectNodes() runs\n+    std::atomic_bool fDisconnect{false};\n+    bool fSentAddr{false};\n+    CSemaphoreGrant grantOutbound;\n+    std::atomic<int> nRefCount{0};\n \n-    // How many full-relay (tx, block, addr) outbound peers we want\n-    int m_max_outbound_full_relay;\n+    const uint64_t nKeyedNetGroup;\n+    std::atomic_bool fPauseRecv{false};\n+    std::atomic_bool fPauseSend{false};\n \n-    // How many block-relay only outbound peers we want\n-    // We do not relay tx or addr messages with these peers\n-    int m_max_outbound_block_relay;\n+    bool IsOutboundOrBlockRelayConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+                return true;\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::ADDR_FETCH:\n+            case ConnectionType::FEELER:\n+                return false;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    int nMaxAddnode;\n-    int nMaxFeeler;\n-    int m_max_outbound;\n-    bool m_use_addrman_outgoing;\n-    CClientUIInterface* clientInterface;\n-    NetEventsInterface* m_msgproc;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* m_banman;\n+        assert(false);\n+    }\n \n-    /**\n-     * Addresses that were saved during the previous clean shutdown. We'll\n-     * attempt to make block-relay-only connections to them.\n-     */\n-    std::vector<CAddress> m_anchors;\n+    bool IsFullOutboundConn() const {\n+        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    }\n \n-    /** SipHasher seeds for deterministic randomness */\n-    const uint64_t nSeed0, nSeed1;\n+    bool IsManualConn() const {\n+        return m_conn_type == ConnectionType::MANUAL;\n+    }\n \n-    /** flag for waking the message processor. */\n-    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n+    bool IsBlockOnlyConn() const {\n+        return m_conn_type == ConnectionType::BLOCK_RELAY;\n+    }\n \n-    std::condition_variable condMsgProc;\n-    Mutex mutexMsgProc;\n-    std::atomic<bool> flagInterruptMsgProc{false};\n+    bool IsFeelerConn() const {\n+        return m_conn_type == ConnectionType::FEELER;\n+    }\n \n-    CThreadInterrupt interruptNet;\n+    bool IsAddrFetchConn() const {\n+        return m_conn_type == ConnectionType::ADDR_FETCH;\n+    }\n \n-    std::thread threadDNSAddressSeed;\n-    std::thread threadSocketHandler;\n-    std::thread threadOpenAddedConnections;\n-    std::thread threadOpenConnections;\n-    std::thread threadMessageHandler;\n+    bool IsInboundConn() const {\n+        return m_conn_type == ConnectionType::INBOUND;\n+    }\n \n-    /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of m_max_outbound_full_relay\n-     *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    /* Whether we send addr messages over this connection */\n+    bool RelayAddrsWithConn() const\n+    {\n+        // Don't relay addr messages to peers that we connect to as block-relay-only\n+        // peers (to prevent adversaries from inferring these links from addr\n+        // traffic).\n+        return m_conn_type != ConnectionType::BLOCK_RELAY;\n+    }\n \n-    /** flag for initiating extra block-relay-only peer connections.\n-     *  this should only be enabled after initial chain sync has occurred,\n-     *  as these connections are intended to be short-lived and low-bandwidth.\n-     */\n-    std::atomic_bool m_start_extra_block_relay_peers{false};\n+    bool ExpectServicesFromConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::FEELER:\n+                return false;\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::ADDR_FETCH:\n+                return true;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n+        assert(false);\n+    }\n \n     /**\n-     * A vector of -bind=<address>:<port>=onion arguments each of which is\n-     * an address and port that are designated for incoming Tor connections.\n+     * Get network the peer connected through.\n+     *\n+     * Returns Network::NET_ONION for *inbound* onion connections,\n+     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n+     * because it doesn't detect the former, and it's not the responsibility of\n+     * the CNetAddr class to know the actual network a peer is connected through.\n+     *\n+     * @return network the peer connected through.\n      */\n-    std::vector<CService> m_onion_binds;\n+    Network ConnectedThroughNetwork() const;\n \n-    friend struct CConnmanTest;\n-    friend struct ConnmanTestMsg;\n-};\n-void Discover();\n-void StartMapPort();\n-void InterruptMapPort();\n-void StopMapPort();\n-uint16_t GetListenPort();\n+protected:\n+    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n \n-/**\n- * Interface for message handling\n- */\n-class NetEventsInterface\n-{\n public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) = 0;\n-    virtual void InitializeNode(CNode* pnode) = 0;\n-    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n+    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_to{false};\n+    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+\n+    // flood relay\n+    std::vector<CAddress> vAddrToSend;\n+    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n+    bool fGetAddr{false};\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+\n+    struct TxRelay {\n+        mutable RecursiveMutex cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+\n+        mutable RecursiveMutex cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        std::chrono::microseconds nNextInvSend{0};\n \n-protected:\n-    /**\n-     * Protected destructor so that instances can only be deleted by derived classes.\n-     * If that restriction is no longer desired, this should be made public and virtual.\n-     */\n-    ~NetEventsInterface() = default;\n-};\n+        RecursiveMutex cs_feeFilter;\n+        // Minimum fee rate with which to filter inv's to this node\n+        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n+        CAmount lastSentFeeFilter{0};\n+        int64_t nextSendTimeFeeFilter{0};\n+    };\n \n-enum\n-{\n-    LOCAL_NONE,   // unknown\n-    LOCAL_IF,     // address a local interface listens on\n-    LOCAL_BIND,   // address explicit bound to\n-    LOCAL_UPNP,   // address reported by UPnP\n-    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n+    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n+    std::unique_ptr<TxRelay> m_tx_relay;\n \n-    LOCAL_MAX\n-};\n+    /** UNIX epoch time of the last block received from this peer that we had\n+     * not yet seen (e.g. not already received from another peer), that passed\n+     * preliminary validity checks and was saved to disk, even if we don't\n+     * connect the block or it eventually fails connection. Used as an inbound\n+     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastBlockTime{0};\n \n-bool IsPeerAddrLocalGood(CNode *pnode);\n-void AdvertiseLocal(CNode *pnode);\n+    /** UNIX epoch time of the last transaction received from this peer that we\n+     * had not yet seen (e.g. not already received from another peer) and that\n+     * was accepted into our mempool. Used as an inbound peer eviction criterium\n+     * in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastTXTime{0};\n \n-/**\n- * Mark a network as reachable or unreachable (no automatic connects to it)\n- * @note Networks are reachable by default\n- */\n-void SetReachable(enum Network net, bool reachable);\n-/** @returns true if the network is reachable, false otherwise */\n-bool IsReachable(enum Network net);\n-/** @returns true if the address is in a reachable network, false otherwise */\n-bool IsReachable(const CNetAddr& addr);\n+    // Ping time measurement:\n+    // The pong reply we're expecting, or 0 if no pong expected.\n+    std::atomic<uint64_t> nPingNonceSent{0};\n+    /** When the last ping was sent, or 0 if no ping was ever sent */\n+    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n+    // Last measured round-trip time.\n+    std::atomic<int64_t> nPingUsecTime{0};\n+    // Best measured round-trip time.\n+    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n+    // Whether a ping is requested.\n+    std::atomic<bool> fPingQueued{false};\n \n-bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n-bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n-void RemoveLocal(const CService& addr);\n-bool SeenLocal(const CService& addr);\n-bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n+    ~CNode();\n+    CNode(const CNode&) = delete;\n+    CNode& operator=(const CNode&) = delete;\n \n+private:\n+    const NodeId id;\n+    const uint64_t nLocalHostNonce;\n+    const ConnectionType m_conn_type;\n+    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n \n-extern bool fDiscover;\n-extern bool fListen;\n+    //! Services offered to this peer.\n+    //!\n+    //! This is supplied by the parent CConnman during peer connection\n+    //! (CConnman::ConnectNode()) from its attribute of the same name.\n+    //!\n+    //! This is const because there is no protocol defined for renegotiating\n+    //! services initially offered to a peer. The set of local services we\n+    //! offer should not change after initialization.\n+    //!\n+    //! An interesting example of this is NODE_NETWORK and initial block\n+    //! download: a node which starts up from scratch doesn't have any blocks\n+    //! to serve, but still advertises NODE_NETWORK because it will eventually\n+    //! fulfill this role after IBD completes. P2P code is written in such a\n+    //! way that it can gracefully handle peers who don't make good on their\n+    //! service advertisements.\n+    const ServiceFlags nLocalServices;\n \n-/** Subversion as sent to the P2P network in `version` messages */\n-extern std::string strSubVersion;\n+    NetPermissionFlags m_permissionFlags{ PF_NONE };\n+    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n-struct LocalServiceInfo {\n-    int nScore;\n-    int nPort;\n-};\n+    mutable RecursiveMutex cs_addrName;\n+    std::string addrName GUARDED_BY(cs_addrName);\n \n-extern RecursiveMutex cs_mapLocalHost;\n-extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n+    // Our address, as reported by the peer\n+    CService addrLocal GUARDED_BY(cs_addrLocal);\n+    mutable RecursiveMutex cs_addrLocal;\n \n-extern const std::string NET_MESSAGE_COMMAND_OTHER;\n-typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n+    const bool m_inbound_onion{false};\n \n-class CNodeStats\n-{\n public:\n-    NodeId nodeid;\n-    ServiceFlags nServices;\n-    bool fRelayTxes;\n-    int64_t nLastSend;\n-    int64_t nLastRecv;\n-    int64_t nLastTXTime;\n-    int64_t nLastBlockTime;\n-    int64_t nTimeConnected;\n-    int64_t nTimeOffset;\n-    std::string addrName;\n-    int nVersion;\n-    std::string cleanSubVer;\n-    bool fInbound;\n-    bool m_bip152_highbandwidth_to;\n-    bool m_bip152_highbandwidth_from;\n-    int m_starting_height;\n-    uint64_t nSendBytes;\n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    uint64_t nRecvBytes;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n-    NetPermissionFlags m_permissionFlags;\n-    int64_t m_ping_usec;\n-    int64_t m_ping_wait_usec;\n-    int64_t m_min_ping_usec;\n-    CAmount minFeeFilter;\n-    // Our address, as reported by the peer\n-    std::string addrLocal;\n-    // Address of this peer\n-    CAddress addr;\n-    // Bind address of our side of the connection\n-    CAddress addrBind;\n-    // Network the peer connected through\n-    Network m_network;\n-    uint32_t m_mapped_as;\n-    std::string m_conn_type_string;\n-};\n \n+    NodeId GetId() const {\n+        return id;\n+    }\n \n+    uint64_t GetLocalNonce() const {\n+        return nLocalHostNonce;\n+    }\n \n-/** Transport protocol agnostic message container.\n- * Ideally it should only contain receive time, payload,\n- * command and size.\n- */\n-class CNetMessage {\n-public:\n-    CDataStream m_recv;                  //!< received message data\n-    std::chrono::microseconds m_time{0}; //!< time of message receipt\n-    uint32_t m_message_size{0};          //!< size of the payload\n-    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n-    std::string m_command;\n+    int GetRefCount() const\n+    {\n+        assert(nRefCount >= 0);\n+        return nRefCount;\n+    }\n \n-    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n+    /**\n+     * Receive bytes from the buffer and deserialize them into messages.\n+     *\n+     * @param[in]   msg_bytes   The raw data\n+     * @param[out]  complete    Set True if at least one message has been\n+     *                          deserialized and is ready to be processed\n+     * @return  True if the peer should stay connected,\n+     *          False if the peer should be disconnected from.\n+     */\n+    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n \n-    void SetVersion(int nVersionIn)\n+    void SetCommonVersion(int greatest_common_version)\n     {\n-        m_recv.SetVersion(nVersionIn);\n+        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n+        m_greatest_common_version = greatest_common_version;\n+    }\n+    int GetCommonVersion() const\n+    {\n+        return m_greatest_common_version;\n     }\n-};\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (command & payload)\n- */\n-class TransportDeserializer {\n-public:\n-    // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n-    // decomposes a message from the context\n-    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n-    virtual ~TransportDeserializer() {}\n-};\n+    CService GetAddrLocal() const;\n+    //! May not be called more than once\n+    void SetAddrLocal(const CService& addrLocalIn);\n \n-class V1TransportDeserializer final : public TransportDeserializer\n-{\n-private:\n-    const CChainParams& m_chain_params;\n-    const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n+    CNode* AddRef()\n+    {\n+        nRefCount++;\n+        return this;\n+    }\n \n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n+    void Release()\n+    {\n+        nRefCount--;\n+    }\n \n-    void Reset() {\n-        vRecv.clear();\n-        hdrbuf.clear();\n-        hdrbuf.resize(24);\n-        in_data = false;\n-        nHdrPos = 0;\n-        nDataPos = 0;\n-        data_hash.SetNull();\n-        hasher.Reset();\n+\n+\n+    void AddAddressKnown(const CAddress& _addr)\n+    {\n+        assert(m_addr_known);\n+        m_addr_known->insert(_addr.GetKey());\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    /**\n+     * Whether the peer supports the address. For example, a peer that does not\n+     * implement BIP155 cannot receive Tor v3 addresses because it requires\n+     * ADDRv2 (BIP155) encoding.\n+     */\n+    bool IsAddrCompatible(const CAddress& addr) const\n     {\n-        Reset();\n+        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n     }\n \n-    bool Complete() const override\n+    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        // Known checking here is only to save space from duplicates.\n+        // SendMessages will filter it again for knowns that were added\n+        // after addresses were pushed.\n+        assert(m_addr_known);\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n+            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n+            } else {\n+                vAddrToSend.push_back(_addr);\n+            }\n+        }\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+\n+    void AddKnownTx(const uint256& hash)\n     {\n-        hdrbuf.SetVersion(nVersionIn);\n-        vRecv.SetVersion(nVersionIn);\n+        if (m_tx_relay != nullptr) {\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            m_tx_relay->filterInventoryKnown.insert(hash);\n+        }\n     }\n-    int Read(Span<const uint8_t>& msg_bytes) override\n+\n+    void PushTxInventory(const uint256& hash)\n     {\n-        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n-        if (ret < 0) {\n-            Reset();\n-        } else {\n-            msg_bytes = msg_bytes.subspan(ret);\n+        if (m_tx_relay == nullptr) return;\n+        LOCK(m_tx_relay->cs_tx_inventory);\n+        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n+            m_tx_relay->setInventoryTxToSend.insert(hash);\n         }\n-        return ret;\n     }\n-    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+\n+    void CloseSocketDisconnect();\n+\n+    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+\n+    ServiceFlags GetLocalServices() const\n+    {\n+        return nLocalServices;\n+    }\n+\n+    std::string GetAddrName() const;\n+    //! Sets the addrName only if it was not previously set\n+    void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    std::string ConnectionTypeAsString() const;\n+\n+    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n+    bool IsInboundOnion() const { return m_inbound_onion; }\n };\n \n-/** The TransportSerializer prepares messages for the network transport\n+/**\n+ * Interface for message handling\n  */\n-class TransportSerializer {\n+class NetEventsInterface\n+{\n public:\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n-    virtual ~TransportSerializer() {}\n-};\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n-class V1TransportSerializer  : public TransportSerializer {\n-public:\n-    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n };\n \n-/** Information about a peer */\n-class CNode\n+class CConnman\n {\n-    friend class CConnman;\n-    friend struct ConnmanTestMsg;\n-\n public:\n-    std::unique_ptr<TransportDeserializer> m_deserializer;\n-    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // socket\n-    std::atomic<ServiceFlags> nServices{NODE_NONE};\n-    SOCKET hSocket GUARDED_BY(cs_hSocket);\n-    /** Total size of all vSendMsg entries */\n-    size_t nSendSize GUARDED_BY(cs_vSend){0};\n-    /** Offset inside the first vSendMsg already sent */\n-    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n-    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n-    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n-    Mutex cs_vSend;\n-    Mutex cs_hSocket;\n-    Mutex cs_vRecv;\n+    enum NumConnections {\n+        CONNECTIONS_NONE = 0,\n+        CONNECTIONS_IN = (1U << 0),\n+        CONNECTIONS_OUT = (1U << 1),\n+        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n+    };\n \n-    RecursiveMutex cs_vProcessMsg;\n-    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n-    size_t nProcessQueueSize{0};\n+    struct Options\n+    {\n+        ServiceFlags nLocalServices = NODE_NONE;\n+        int nMaxConnections = 0;\n+        int m_max_outbound_full_relay = 0;\n+        int m_max_outbound_block_relay = 0;\n+        int nMaxAddnode = 0;\n+        int nMaxFeeler = 0;\n+        CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n+        BanMan* m_banman = nullptr;\n+        unsigned int nSendBufferMaxSize = 0;\n+        unsigned int nReceiveFloodSize = 0;\n+        uint64_t nMaxOutboundLimit = 0;\n+        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+        std::vector<NetWhitebindPermissions> vWhiteBinds;\n+        std::vector<CService> vBinds;\n+        std::vector<CService> onion_binds;\n+        bool m_use_addrman_outgoing = true;\n+        std::vector<std::string> m_specified_outgoing;\n+        std::vector<std::string> m_added_nodes;\n+        std::vector<bool> m_asmap;\n+    };\n \n-    RecursiveMutex cs_sendProcessing;\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n+        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n+        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n+        clientInterface = connOptions.uiInterface;\n+        m_banman = connOptions.m_banman;\n+        m_msgproc = connOptions.m_msgproc;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n+        {\n+            LOCK(cs_totalBytesSent);\n+            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        }\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+        {\n+            LOCK(cs_vAddedNodes);\n+            vAddedNodes = connOptions.m_added_nodes;\n+        }\n+        m_onion_binds = connOptions.onion_binds;\n+    }\n \n-    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n+    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n+    ~CConnman();\n+    bool Start(CScheduler& scheduler, const Options& options);\n \n-    std::atomic<int64_t> nLastSend{0};\n-    std::atomic<int64_t> nLastRecv{0};\n-    const int64_t nTimeConnected;\n-    std::atomic<int64_t> nTimeOffset{0};\n-    // Address of this peer\n-    const CAddress addr;\n-    // Bind address of our side of the connection\n-    const CAddress addrBind;\n-    std::atomic<int> nVersion{0};\n-    RecursiveMutex cs_SubVer;\n-    /**\n-     * cleanSubVer is a sanitized string of the user agent byte array we read\n-     * from the wire. This cleaned string can safely be logged or displayed.\n-     */\n-    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n-    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n-    bool HasPermission(NetPermissionFlags permission) const {\n-        return NetPermissions::HasFlag(m_permissionFlags, permission);\n-    }\n-    bool fClient{false}; // set by version message\n-    bool m_limited_node{false}; //after BIP159, set by version message\n-    /**\n-     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n-     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n-     */\n-    std::atomic_bool m_wants_addrv2{false};\n-    std::atomic_bool fSuccessfullyConnected{false};\n-    // Setting fDisconnect to true will cause the node to be disconnected the\n-    // next time DisconnectNodes() runs\n-    std::atomic_bool fDisconnect{false};\n-    bool fSentAddr{false};\n-    CSemaphoreGrant grantOutbound;\n-    std::atomic<int> nRefCount{0};\n+    void StopThreads();\n+    void StopNodes();\n+    void Stop()\n+    {\n+        StopThreads();\n+        StopNodes();\n+    };\n+\n+    void Interrupt();\n+    bool GetNetworkActive() const { return fNetworkActive; };\n+    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n+    void SetNetworkActive(bool active);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n+    bool CheckIncomingNonce(uint64_t nonce);\n+\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n+\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    void ForEachNode(const NodeFn& func) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    const uint64_t nKeyedNetGroup;\n-    std::atomic_bool fPauseRecv{false};\n-    std::atomic_bool fPauseSend{false};\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    bool IsOutboundOrBlockRelayConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-                return true;\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::ADDR_FETCH:\n-            case ConnectionType::FEELER:\n-                return false;\n-        } // no default case, so the compiler can warn about missing cases\n+    // Addrman functions\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void MarkAddressGood(const CAddress& addr);\n+    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    /**\n+     * Cache is used to minimize topology leaks, so it should\n+     * be used for all non-trusted calls, for example, p2p.\n+     * A non-malicious call (from RPC or a peer with addr permission) should\n+     * call the function without a parameter to avoid using the cache.\n+     */\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n \n-        assert(false);\n-    }\n+    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n \n-    bool IsFullOutboundConn() const {\n-        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    void StartExtraBlockRelayPeers() {\n+        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n+        m_start_extra_block_relay_peers = true;\n     }\n \n-    bool IsManualConn() const {\n-        return m_conn_type == ConnectionType::MANUAL;\n-    }\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraFullOutboundCount();\n+    // Count the number of block-relay-only peers we have over our limit.\n+    int GetExtraBlockRelayCount();\n \n-    bool IsBlockOnlyConn() const {\n-        return m_conn_type == ConnectionType::BLOCK_RELAY;\n-    }\n+    bool AddNode(const std::string& node);\n+    bool RemoveAddedNode(const std::string& node);\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    bool IsFeelerConn() const {\n-        return m_conn_type == ConnectionType::FEELER;\n-    }\n+    size_t GetNodeCount(NumConnections num);\n+    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    bool DisconnectNode(const std::string& node);\n+    bool DisconnectNode(const CSubNet& subnet);\n+    bool DisconnectNode(const CNetAddr& addr);\n+    bool DisconnectNode(NodeId id);\n \n-    bool IsAddrFetchConn() const {\n-        return m_conn_type == ConnectionType::ADDR_FETCH;\n-    }\n+    //! Used to convey which local services we are offering peers during node\n+    //! connection.\n+    //!\n+    //! The data returned by this is used in CNode construction,\n+    //! which is used to advertise which services we are offering\n+    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n+    ServiceFlags GetLocalServices() const;\n \n-    bool IsInboundConn() const {\n-        return m_conn_type == ConnectionType::INBOUND;\n-    }\n+    uint64_t GetMaxOutboundTarget();\n+    std::chrono::seconds GetMaxOutboundTimeframe();\n \n-    /* Whether we send addr messages over this connection */\n-    bool RelayAddrsWithConn() const\n-    {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n-        // peers (to prevent adversaries from inferring these links from addr\n-        // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n-    }\n+    //! check if the outbound target is reached\n+    //! if param historicalBlockServingLimit is set true, the function will\n+    //! response true if the limit for serving historical blocks has been reached\n+    bool OutboundTargetReached(bool historicalBlockServingLimit);\n \n-    bool ExpectServicesFromConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::FEELER:\n-                return false;\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-            case ConnectionType::ADDR_FETCH:\n-                return true;\n-        } // no default case, so the compiler can warn about missing cases\n+    //! response the bytes left in the current max outbound cycle\n+    //! in case of no limit, it will always response 0\n+    uint64_t GetOutboundTargetBytesLeft();\n \n-        assert(false);\n-    }\n+    //! returns the time left in the current max outbound cycle\n+    //! in case of no limit, it will always return 0\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n \n-    /**\n-     * Get network the peer connected through.\n-     *\n-     * Returns Network::NET_ONION for *inbound* onion connections,\n-     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n-     * because it doesn't detect the former, and it's not the responsibility of\n-     * the CNetAddr class to know the actual network a peer is connected through.\n-     *\n-     * @return network the peer connected through.\n-     */\n-    Network ConnectedThroughNetwork() const;\n+    uint64_t GetTotalBytesRecv();\n+    uint64_t GetTotalBytesSent();\n \n-protected:\n-    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n+    /** Get a unique deterministic randomizer. */\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-public:\n-    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_to{false};\n-    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+    unsigned int GetReceiveFloodSize() const;\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n-    bool fGetAddr{false};\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    void WakeMessageHandler();\n \n-    struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n+        Works assuming that a single interval is used.\n+        Variable intervals will result in privacy decrease.\n+    */\n+    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n-        // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n-        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n+    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n-        RecursiveMutex cs_feeFilter;\n-        // Minimum fee rate with which to filter inv's to this node\n-        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n-        CAmount lastSentFeeFilter{0};\n-        int64_t nextSendTimeFeeFilter{0};\n+private:\n+    struct ListenSocket {\n+    public:\n+        SOCKET socket;\n+        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n+        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n+    private:\n+        NetPermissionFlags m_permissions;\n     };\n \n-    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n-    std::unique_ptr<TxRelay> m_tx_relay;\n+    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n+    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n+    bool InitBinds(\n+        const std::vector<CService>& binds,\n+        const std::vector<NetWhitebindPermissions>& whiteBinds,\n+        const std::vector<CService>& onion_binds);\n \n-    /** UNIX epoch time of the last block received from this peer that we had\n-     * not yet seen (e.g. not already received from another peer), that passed\n-     * preliminary validity checks and was saved to disk, even if we don't\n-     * connect the block or it eventually fails connection. Used as an inbound\n-     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastBlockTime{0};\n+    void ThreadOpenAddedConnections();\n+    void AddAddrFetch(const std::string& strDest);\n+    void ProcessAddrFetch();\n+    void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadMessageHandler();\n+    void AcceptConnection(const ListenSocket& hListenSocket);\n+    void DisconnectNodes();\n+    void NotifyNumConnectionsChanged();\n+    void InactivityCheck(CNode *pnode);\n+    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketHandler();\n+    void ThreadSocketHandler();\n+    void ThreadDNSAddressSeed();\n \n-    /** UNIX epoch time of the last transaction received from this peer that we\n-     * had not yet seen (e.g. not already received from another peer) and that\n-     * was accepted into our mempool. Used as an inbound peer eviction criterium\n-     * in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastTXTime{0};\n+    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent{0};\n-    /** When the last ping was sent, or 0 if no ping was ever sent */\n-    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n-    // Last measured round-trip time.\n-    std::atomic<int64_t> nPingUsecTime{0};\n-    // Best measured round-trip time.\n-    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued{false};\n+    CNode* FindNode(const CNetAddr& ip);\n+    CNode* FindNode(const CSubNet& subNet);\n+    CNode* FindNode(const std::string& addrName);\n+    CNode* FindNode(const CService& addr);\n+\n+    /**\n+     * Determine whether we're already connected to a given address, in order to\n+     * avoid initiating duplicate connections.\n+     */\n+    bool AlreadyConnectedToAddress(const CAddress& addr);\n+\n+    bool AttemptToEvictConnection();\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n+    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n+\n+    void DeleteNode(CNode* pnode);\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n-    ~CNode();\n-    CNode(const CNode&) = delete;\n-    CNode& operator=(const CNode&) = delete;\n+    NodeId GetNewNodeId();\n \n-private:\n-    const NodeId id;\n-    const uint64_t nLocalHostNonce;\n-    const ConnectionType m_conn_type;\n-    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n+    size_t SocketSendData(CNode& node) const EXCLUSIVE_LOCKS_REQUIRED(node.cs_vSend);\n+    void DumpAddresses();\n \n-    //! Services offered to this peer.\n-    //!\n-    //! This is supplied by the parent CConnman during peer connection\n-    //! (CConnman::ConnectNode()) from its attribute of the same name.\n-    //!\n-    //! This is const because there is no protocol defined for renegotiating\n-    //! services initially offered to a peer. The set of local services we\n-    //! offer should not change after initialization.\n-    //!\n-    //! An interesting example of this is NODE_NETWORK and initial block\n-    //! download: a node which starts up from scratch doesn't have any blocks\n-    //! to serve, but still advertises NODE_NETWORK because it will eventually\n-    //! fulfill this role after IBD completes. P2P code is written in such a\n-    //! way that it can gracefully handle peers who don't make good on their\n-    //! service advertisements.\n-    const ServiceFlags nLocalServices;\n+    // Network stats\n+    void RecordBytesRecv(uint64_t bytes);\n+    void RecordBytesSent(uint64_t bytes);\n \n-    NetPermissionFlags m_permissionFlags{ PF_NONE };\n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n+    /**\n+     * Return vector of current BLOCK_RELAY peers.\n+     */\n+    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n \n-    mutable RecursiveMutex cs_addrName;\n-    std::string addrName GUARDED_BY(cs_addrName);\n+    // Whether the node should be passed out in ForEach* callbacks\n+    static bool NodeFullyConnected(const CNode* pnode);\n \n-    // Our address, as reported by the peer\n-    CService addrLocal GUARDED_BY(cs_addrLocal);\n-    mutable RecursiveMutex cs_addrLocal;\n+    // Network usage totals\n+    RecursiveMutex cs_totalBytesRecv;\n+    RecursiveMutex cs_totalBytesSent;\n+    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n+    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n-    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n-    const bool m_inbound_onion{false};\n+    // outbound limit & stats\n+    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n+    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n+    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n \n-public:\n+    // P2P timeout in seconds\n+    int64_t m_peer_connect_timeout;\n \n-    NodeId GetId() const {\n-        return id;\n-    }\n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n \n-    uint64_t GetLocalNonce() const {\n-        return nLocalHostNonce;\n-    }\n+    unsigned int nSendBufferMaxSize{0};\n+    unsigned int nReceiveFloodSize{0};\n \n-    int GetRefCount() const\n-    {\n-        assert(nRefCount >= 0);\n-        return nRefCount;\n-    }\n+    std::vector<ListenSocket> vhListenSocket;\n+    std::atomic<bool> fNetworkActive{true};\n+    bool fAddressesInitialized{false};\n+    CAddrMan addrman;\n+    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n+    RecursiveMutex m_addr_fetches_mutex;\n+    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n+    RecursiveMutex cs_vAddedNodes;\n+    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n+    std::list<CNode*> vNodesDisconnected;\n+    mutable RecursiveMutex cs_vNodes;\n+    std::atomic<NodeId> nLastNodeId{0};\n+    unsigned int nPrevNodeCount{0};\n \n     /**\n-     * Receive bytes from the buffer and deserialize them into messages.\n-     *\n-     * @param[in]   msg_bytes   The raw data\n-     * @param[out]  complete    Set True if at least one message has been\n-     *                          deserialized and is ready to be processed\n-     * @return  True if the peer should stay connected,\n-     *          False if the peer should be disconnected from.\n+     * Cache responses to addr requests to minimize privacy leak.\n+     * Attack example: scraping addrs in real-time may allow an attacker\n+     * to infer new connections of the victim by detecting new records\n+     * with fresh timestamps (per self-announcement).\n      */\n-    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n-\n-    void SetCommonVersion(int greatest_common_version)\n-    {\n-        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n-        m_greatest_common_version = greatest_common_version;\n-    }\n-    int GetCommonVersion() const\n-    {\n-        return m_greatest_common_version;\n-    }\n+    struct CachedAddrResponse {\n+        std::vector<CAddress> m_addrs_response_cache;\n+        std::chrono::microseconds m_cache_entry_expiration{0};\n+    };\n \n-    CService GetAddrLocal() const;\n-    //! May not be called more than once\n-    void SetAddrLocal(const CService& addrLocalIn);\n+    /**\n+     * Addr responses stored in different caches\n+     * per (network, local socket) prevent cross-network node identification.\n+     * If a node for example is multi-homed under Tor and IPv6,\n+     * a single cache (or no cache at all) would let an attacker\n+     * to easily detect that it is the same node by comparing responses.\n+     * Indexing by local socket prevents leakage when a node has multiple\n+     * listening addresses on the same network.\n+     *\n+     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n+     * distinct Network (up to 5) we have/had an inbound peer from,\n+     * resulting in at most ~196 KB. Every separate local socket may\n+     * add up to ~196 KB extra.\n+     */\n+    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n \n-    CNode* AddRef()\n-    {\n-        nRefCount++;\n-        return this;\n-    }\n+    /**\n+     * Services this instance offers.\n+     *\n+     * This data is replicated in each CNode instance we create during peer\n+     * connection (in ConnectNode()) under a member also called\n+     * nLocalServices.\n+     *\n+     * This data is not marked const, but after being set it should not\n+     * change. See the note in CNode::nLocalServices documentation.\n+     *\n+     * \\sa CNode::nLocalServices\n+     */\n+    ServiceFlags nLocalServices;\n \n-    void Release()\n-    {\n-        nRefCount--;\n-    }\n+    std::unique_ptr<CSemaphore> semOutbound;\n+    std::unique_ptr<CSemaphore> semAddnode;\n+    int nMaxConnections;\n \n+    // How many full-relay (tx, block, addr) outbound peers we want\n+    int m_max_outbound_full_relay;\n \n+    // How many block-relay only outbound peers we want\n+    // We do not relay tx or addr messages with these peers\n+    int m_max_outbound_block_relay;\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        assert(m_addr_known);\n-        m_addr_known->insert(_addr.GetKey());\n-    }\n+    int nMaxAddnode;\n+    int nMaxFeeler;\n+    int m_max_outbound;\n+    bool m_use_addrman_outgoing;\n+    CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* m_banman;\n \n     /**\n-     * Whether the peer supports the address. For example, a peer that does not\n-     * implement BIP155 cannot receive Tor v3 addresses because it requires\n-     * ADDRv2 (BIP155) encoding.\n+     * Addresses that were saved during the previous clean shutdown. We'll\n+     * attempt to make block-relay-only connections to them.\n      */\n-    bool IsAddrCompatible(const CAddress& addr) const\n-    {\n-        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n-    }\n+    std::vector<CAddress> m_anchors;\n \n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n-    {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n-        }\n-    }\n+    /** SipHasher seeds for deterministic randomness */\n+    const uint64_t nSeed0, nSeed1;\n \n+    /** flag for waking the message processor. */\n+    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n \n-    void AddKnownTx(const uint256& hash)\n-    {\n-        if (m_tx_relay != nullptr) {\n-            LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n-        }\n-    }\n+    std::condition_variable condMsgProc;\n+    Mutex mutexMsgProc;\n+    std::atomic<bool> flagInterruptMsgProc{false};\n \n-    void PushTxInventory(const uint256& hash)\n-    {\n-        if (m_tx_relay == nullptr) return;\n-        LOCK(m_tx_relay->cs_tx_inventory);\n-        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n-        }\n-    }\n+    CThreadInterrupt interruptNet;\n \n-    void CloseSocketDisconnect();\n+    std::thread threadDNSAddressSeed;\n+    std::thread threadSocketHandler;\n+    std::thread threadOpenAddedConnections;\n+    std::thread threadOpenConnections;\n+    std::thread threadMessageHandler;\n \n-    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of m_max_outbound_full_relay\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n \n-    ServiceFlags GetLocalServices() const\n-    {\n-        return nLocalServices;\n-    }\n+    /** flag for initiating extra block-relay-only peer connections.\n+     *  this should only be enabled after initial chain sync has occurred,\n+     *  as these connections are intended to be short-lived and low-bandwidth.\n+     */\n+    std::atomic_bool m_start_extra_block_relay_peers{false};\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n+    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n \n-    std::string ConnectionTypeAsString() const;\n+    /**\n+     * A vector of -bind=<address>:<port>=onion arguments each of which is\n+     * an address and port that are designated for incoming Tor connections.\n+     */\n+    std::vector<CService> m_onion_binds;\n \n-    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n-    bool IsInboundOnion() const { return m_inbound_onion; }\n+    friend struct CConnmanTest;\n+    friend struct ConnmanTestMsg;\n };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r553182212",
      "id" : 553182212,
      "in_reply_to_id" : 552621025,
      "line" : 1216,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE4MjIxMg==",
      "original_commit_id" : "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "original_line" : 1216,
      "original_position" : 1906,
      "original_start_line" : null,
      "path" : "src/net.h",
      "position" : 1906,
      "pull_request_review_id" : 563299405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-07T08:42:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/553182212",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK fa210689e2",
      "created_at" : "2021-01-07T09:20:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755991945",
      "id" : 755991945,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NTk5MTk0NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-07T09:20:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755991945",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   }
]
