[
   {
      "author_association" : "MEMBER",
      "body" : "Nice find and welcome as a contributor!\r\n\r\nConcept ACK\r\n\r\nIn addition to `HTTP_INTERNAL` it seems like we have the same issue also for `HTTP_BADMETHOD` and `HTTP_NOTFOUND`?\r\n\r\n```sh\r\n$ for S in $(git grep '>WriteReply(' | tr \"(),\" \"\\n\" | egrep ^HTTP_ | sort -u); do\r\n      echo \"=== $S\"\r\n      grep \"$S\" src/rpc/protocol.h\r\n      echo\r\n  done\r\n=== HTTP_BADMETHOD\r\n\r\n=== HTTP_BAD_METHOD\r\n    HTTP_BAD_METHOD            = 405,\r\n\r\n=== HTTP_FORBIDDEN\r\n    HTTP_FORBIDDEN             = 403,\r\n\r\n=== HTTP_INTERNAL\r\n    HTTP_INTERNAL_SERVER_ERROR = 500,\r\n\r\n=== HTTP_NOTFOUND\r\n\r\n=== HTTP_OK\r\n    HTTP_OK                    = 200,\r\n\r\n=== HTTP_UNAUTHORIZED\r\n    HTTP_UNAUTHORIZED          = 401,\r\n\r\n```",
      "created_at" : "2020-02-18T07:09:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-587313899",
      "id" : 587313899,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzMxMzg5OQ==",
      "updated_at" : "2020-02-18T07:09:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587313899",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Thanks! I've stumbled upon this while debugging a client that exceeds the HTTP worker queue. I'll cleanup the remaining status codes.",
      "created_at" : "2020-02-18T07:13:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-587315046",
      "id" : 587315046,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzMxNTA0Ng==",
      "updated_at" : "2020-02-18T07:13:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587315046",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7702854?v=4",
         "events_url" : "https://api.github.com/users/toxeus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/toxeus/followers",
         "following_url" : "https://api.github.com/users/toxeus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/toxeus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/toxeus",
         "id" : 7702854,
         "login" : "toxeus",
         "node_id" : "MDQ6VXNlcjc3MDI4NTQ=",
         "organizations_url" : "https://api.github.com/users/toxeus/orgs",
         "received_events_url" : "https://api.github.com/users/toxeus/received_events",
         "repos_url" : "https://api.github.com/users/toxeus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/toxeus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/toxeus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/toxeus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@toxeus To get some structure in the handling of status code we might want to consider changing from `enum HTTPStatusCode` to `enum class HTTPStatusCode`?\r\n\r\nSomething along the lines of ...\r\n\r\n<details><summary>Click for patch</summary>\r\n\r\n```diff\r\ndiff --git a/src/bitcoin-cli.cpp b/src/bitcoin-cli.cpp\r\nindex c085095a2..b9eeff819 100644\r\n--- a/src/bitcoin-cli.cpp\r\n+++ b/src/bitcoin-cli.cpp\r\n@@ -388,7 +388,7 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\r\n             responseErrorMessage = strprintf(\" (error code %d - \\\"%s\\\")\", response.error, http_errorstring(response.error));\r\n         }\r\n         throw CConnectionFailed(strprintf(\"Could not connect to the server %s:%d%s\\n\\nMake sure the bitcoind server is running and that you are connecting to the correct RPC port.\", host, port, responseErrorMessage));\r\n-    } else if (response.status == HTTP_UNAUTHORIZED) {\r\n+    } else if (response.status == static_cast<int>(HTTPStatusCode::HTTP_UNAUTHORIZED)) {\r\n         if (failedToGetAuthCookie) {\r\n             throw std::runtime_error(strprintf(\r\n                 \"Could not locate RPC credentials. No authentication cookie could be found, and RPC password is not set.  See -rpcpassword and -stdinrpcpass.  Configuration file: (%s)\",\r\n@@ -396,7 +396,7 @@ static UniValue CallRPC(BaseRequestHandler *rh, const std::string& strMethod, co\r\n         } else {\r\n             throw std::runtime_error(\"Authorization failed: Incorrect rpcuser or rpcpassword\");\r\n         }\r\n-    } else if (response.status >= 400 && response.status != HTTP_BAD_REQUEST && response.status != HTTP_NOT_FOUND && response.status != HTTP_INTERNAL_SERVER_ERROR)\r\n+    } else if (response.status >= 400 && response.status != static_cast<int>(HTTPStatusCode::HTTP_BAD_REQUEST) && response.status != static_cast<int>(HTTPStatusCode::HTTP_NOT_FOUND) && response.status != static_cast<int>(HTTPStatusCode::HTTP_INTERNAL_SERVER_ERROR))\r\n         throw std::runtime_error(strprintf(\"server returned HTTP error %d\", response.status));\r\n     else if (response.body.empty())\r\n         throw std::runtime_error(\"no response from server\");\r\ndiff --git a/src/httprpc.cpp b/src/httprpc.cpp\r\nindex ff7578922..ec5734997 100644\r\n--- a/src/httprpc.cpp\r\n+++ b/src/httprpc.cpp\r\n@@ -76,13 +76,13 @@ static bool g_rpc_whitelist_default = false;\r\n static void JSONErrorReply(HTTPRequest* req, const UniValue& objError, const UniValue& id)\r\n {\r\n     // Send error reply from json-rpc error object\r\n-    int nStatus = HTTP_INTERNAL_SERVER_ERROR;\r\n+    HTTPStatusCode nStatus = HTTPStatusCode::HTTP_INTERNAL_SERVER_ERROR;\r\n     int code = find_value(objError, \"code\").get_int();\r\n \r\n     if (code == RPC_INVALID_REQUEST)\r\n-        nStatus = HTTP_BAD_REQUEST;\r\n+        nStatus = HTTPStatusCode::HTTP_BAD_REQUEST;\r\n     else if (code == RPC_METHOD_NOT_FOUND)\r\n-        nStatus = HTTP_NOT_FOUND;\r\n+        nStatus = HTTPStatusCode::HTTP_NOT_FOUND;\r\n \r\n     std::string strReply = JSONRPCReply(NullUniValue, objError, id);\r\n \r\n@@ -155,14 +155,14 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\r\n {\r\n     // JSONRPC handles only POST\r\n     if (req->GetRequestMethod() != HTTPRequest::POST) {\r\n-        req->WriteReply(HTTP_BAD_METHOD, \"JSONRPC server handles only POST requests\");\r\n+        req->WriteReply(HTTPStatusCode::HTTP_BAD_METHOD, \"JSONRPC server handles only POST requests\");\r\n         return false;\r\n     }\r\n     // Check authorization\r\n     std::pair<bool, std::string> authHeader = req->GetHeader(\"authorization\");\r\n     if (!authHeader.first) {\r\n         req->WriteHeader(\"WWW-Authenticate\", WWW_AUTH_HEADER_DATA);\r\n-        req->WriteReply(HTTP_UNAUTHORIZED);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_UNAUTHORIZED);\r\n         return false;\r\n     }\r\n \r\n@@ -177,7 +177,7 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\r\n         MilliSleep(250);\r\n \r\n         req->WriteHeader(\"WWW-Authenticate\", WWW_AUTH_HEADER_DATA);\r\n-        req->WriteReply(HTTP_UNAUTHORIZED);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_UNAUTHORIZED);\r\n         return false;\r\n     }\r\n \r\n@@ -194,7 +194,7 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\r\n         bool user_has_whitelist = g_rpc_whitelist.count(jreq.authUser);\r\n         if (!user_has_whitelist && g_rpc_whitelist_default) {\r\n             LogPrintf(\"RPC User %s not allowed to call any methods\\n\", jreq.authUser);\r\n-            req->WriteReply(HTTP_FORBIDDEN);\r\n+            req->WriteReply(HTTPStatusCode::HTTP_FORBIDDEN);\r\n             return false;\r\n \r\n         // singleton request\r\n@@ -202,7 +202,7 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\r\n             jreq.parse(valRequest);\r\n             if (user_has_whitelist && !g_rpc_whitelist[jreq.authUser].count(jreq.strMethod)) {\r\n                 LogPrintf(\"RPC User %s not allowed to call method %s\\n\", jreq.authUser, jreq.strMethod);\r\n-                req->WriteReply(HTTP_FORBIDDEN);\r\n+                req->WriteReply(HTTPStatusCode::HTTP_FORBIDDEN);\r\n                 return false;\r\n             }\r\n             UniValue result = tableRPC.execute(jreq);\r\n@@ -222,7 +222,7 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\r\n                         std::string strMethod = find_value(request, \"method\").get_str();\r\n                         if (!g_rpc_whitelist[jreq.authUser].count(strMethod)) {\r\n                             LogPrintf(\"RPC User %s not allowed to call method %s\\n\", jreq.authUser, strMethod);\r\n-                            req->WriteReply(HTTP_FORBIDDEN);\r\n+                            req->WriteReply(HTTPStatusCode::HTTP_FORBIDDEN);\r\n                             return false;\r\n                         }\r\n                     }\r\n@@ -234,7 +234,7 @@ static bool HTTPReq_JSONRPC(HTTPRequest* req, const std::string &)\r\n             throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\r\n \r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strReply);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strReply);\r\n     } catch (const UniValue& objError) {\r\n         JSONErrorReply(req, objError, jreq.id);\r\n         return false;\r\ndiff --git a/src/httpserver.cpp b/src/httpserver.cpp\r\nindex 0e13b8580..54f0d077c 100644\r\n--- a/src/httpserver.cpp\r\n+++ b/src/httpserver.cpp\r\n@@ -228,7 +228,7 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\r\n     if (!ClientAllowed(hreq->GetPeer())) {\r\n         LogPrint(BCLog::HTTP, \"HTTP request from %s rejected: Client network is not allowed RPC access\\n\",\r\n                  hreq->GetPeer().ToString());\r\n-        hreq->WriteReply(HTTP_FORBIDDEN);\r\n+        hreq->WriteReply(HTTPStatusCode::HTTP_FORBIDDEN);\r\n         return;\r\n     }\r\n \r\n@@ -236,7 +236,7 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\r\n     if (hreq->GetRequestMethod() == HTTPRequest::UNKNOWN) {\r\n         LogPrint(BCLog::HTTP, \"HTTP request from %s rejected: Unknown HTTP request method\\n\",\r\n                  hreq->GetPeer().ToString());\r\n-        hreq->WriteReply(HTTP_BADMETHOD);\r\n+        hreq->WriteReply(HTTPStatusCode::HTTP_BAD_METHOD);\r\n         return;\r\n     }\r\n \r\n@@ -268,10 +268,10 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\r\n             item.release(); /* if true, queue took ownership */\r\n         else {\r\n             LogPrintf(\"WARNING: request rejected because http work queue depth exceeded, it can be increased with the -rpcworkqueue= setting\\n\");\r\n-            item->req->WriteReply(HTTP_INTERNAL, \"Work queue depth exceeded\");\r\n+            item->req->WriteReply(HTTPStatusCode::HTTP_INTERNAL_SERVER_ERROR, \"Work queue depth exceeded\");\r\n         }\r\n     } else {\r\n-        hreq->WriteReply(HTTP_NOTFOUND);\r\n+        hreq->WriteReply(HTTPStatusCode::HTTP_NOT_FOUND);\r\n     }\r\n }\r\n \r\n@@ -519,7 +519,7 @@ HTTPRequest::~HTTPRequest()\r\n     if (!replySent) {\r\n         // Keep track of whether reply was sent to avoid request leaks\r\n         LogPrintf(\"%s: Unhandled request\\n\", __func__);\r\n-        WriteReply(HTTP_INTERNAL, \"Unhandled request\");\r\n+        WriteReply(HTTPStatusCode::HTTP_INTERNAL_SERVER_ERROR, \"Unhandled request\");\r\n     }\r\n     // evhttpd cleans up the request, as long as a reply was sent.\r\n }\r\n@@ -567,7 +567,7 @@ void HTTPRequest::WriteHeader(const std::string& hdr, const std::string& value)\r\n  * Replies must be sent in the main loop in the main http thread,\r\n  * this cannot be done from worker threads.\r\n  */\r\n-void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\r\n+void HTTPRequest::WriteReply(HTTPStatusCode nStatus, const std::string& strReply)\r\n {\r\n     assert(!replySent && req);\r\n     if (ShutdownRequested()) {\r\n@@ -579,7 +579,7 @@ void HTTPRequest::WriteReply(int nStatus, const std::string& strReply)\r\n     evbuffer_add(evb, strReply.data(), strReply.size());\r\n     auto req_copy = req;\r\n     HTTPEvent* ev = new HTTPEvent(eventBase, true, [req_copy, nStatus]{\r\n-        evhttp_send_reply(req_copy, nStatus, nullptr, nullptr);\r\n+        evhttp_send_reply(req_copy, static_cast<int>(nStatus), nullptr, nullptr);\r\n         // Re-enable reading from the socket. This is the second part of the libevent\r\n         // workaround above.\r\n         if (event_get_version_number() >= 0x02010600 && event_get_version_number() < 0x02020001) {\r\ndiff --git a/src/httpserver.h b/src/httpserver.h\r\nindex 46820e6ae..f9710f844 100644\r\n--- a/src/httpserver.h\r\n+++ b/src/httpserver.h\r\n@@ -5,6 +5,8 @@\r\n #ifndef BITCOIN_HTTPSERVER_H\r\n #define BITCOIN_HTTPSERVER_H\r\n \r\n+#include <rpc/protocol.h>\r\n+\r\n #include <string>\r\n #include <functional>\r\n \r\n@@ -112,7 +114,7 @@ public:\r\n      * @note Can be called only once. As this will give the request back to the\r\n      * main thread, do not call any other HTTPRequest methods after calling this.\r\n      */\r\n-    void WriteReply(int nStatus, const std::string& strReply = \"\");\r\n+    void WriteReply(HTTPStatusCode nStatus, const std::string& strReply = \"\");\r\n };\r\n \r\n /** Event handler closure.\r\ndiff --git a/src/rest.cpp b/src/rest.cpp\r\nindex 062955758..cab7226a1 100644\r\n--- a/src/rest.cpp\r\n+++ b/src/rest.cpp\r\n@@ -83,7 +83,7 @@ static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, std::string me\r\n static CTxMemPool* GetMemPool(HTTPRequest* req)\r\n {\r\n     if (!g_rpc_node || !g_rpc_node->mempool) {\r\n-        RESTERR(req, HTTP_NOT_FOUND, \"Mempool disabled or instance not found\");\r\n+        RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"Mempool disabled or instance not found\");\r\n         return nullptr;\r\n     }\r\n     return g_rpc_node->mempool;\r\n@@ -130,7 +130,7 @@ static bool CheckWarmup(HTTPRequest* req)\r\n {\r\n     std::string statusmessage;\r\n     if (RPCIsInWarmup(&statusmessage))\r\n-         return RESTERR(req, HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \" + statusmessage);\r\n+         return RESTERR(req, HTTPStatusCode::HTTP_SERVICE_UNAVAILABLE, \"Service temporarily unavailable: \" + statusmessage);\r\n     return true;\r\n }\r\n \r\n@@ -145,16 +145,16 @@ static bool rest_headers(HTTPRequest* req,\r\n     boost::split(path, param, boost::is_any_of(\"/\"));\r\n \r\n     if (path.size() != 2)\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"No header count specified. Use /rest/headers/<count>/<hash>.<ext>.\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"No header count specified. Use /rest/headers/<count>/<hash>.<ext>.\");\r\n \r\n     long count = strtol(path[0].c_str(), nullptr, 10);\r\n     if (count < 1 || count > 2000)\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Header count out of range: \" + path[0]);\r\n \r\n     std::string hashStr = path[1];\r\n     uint256 hash;\r\n     if (!ParseHashStr(hashStr, hash))\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\r\n \r\n     const CBlockIndex* tip = nullptr;\r\n     std::vector<const CBlockIndex *> headers;\r\n@@ -180,7 +180,7 @@ static bool rest_headers(HTTPRequest* req,\r\n \r\n         std::string binaryHeader = ssHeader.str();\r\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\r\n-        req->WriteReply(HTTP_OK, binaryHeader);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, binaryHeader);\r\n         return true;\r\n     }\r\n \r\n@@ -192,7 +192,7 @@ static bool rest_headers(HTTPRequest* req,\r\n \r\n         std::string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\r\n-        req->WriteReply(HTTP_OK, strHex);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strHex);\r\n         return true;\r\n     }\r\n     case RetFormat::JSON: {\r\n@@ -202,11 +202,11 @@ static bool rest_headers(HTTPRequest* req,\r\n         }\r\n         std::string strJSON = jsonHeaders.write() + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strJSON);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strJSON);\r\n         return true;\r\n     }\r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: .bin, .hex)\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: .bin, .hex)\");\r\n     }\r\n     }\r\n }\r\n@@ -222,7 +222,7 @@ static bool rest_block(HTTPRequest* req,\r\n \r\n     uint256 hash;\r\n     if (!ParseHashStr(hashStr, hash))\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\r\n \r\n     CBlock block;\r\n     CBlockIndex* pblockindex = nullptr;\r\n@@ -232,14 +232,14 @@ static bool rest_block(HTTPRequest* req,\r\n         tip = ::ChainActive().Tip();\r\n         pblockindex = LookupBlockIndex(hash);\r\n         if (!pblockindex) {\r\n-            return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\r\n+            return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, hashStr + \" not found\");\r\n         }\r\n \r\n         if (IsBlockPruned(pblockindex))\r\n-            return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\r\n+            return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, hashStr + \" not available (pruned data)\");\r\n \r\n         if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\r\n-            return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\r\n+            return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, hashStr + \" not found\");\r\n     }\r\n \r\n     switch (rf) {\r\n@@ -248,7 +248,7 @@ static bool rest_block(HTTPRequest* req,\r\n         ssBlock << block;\r\n         std::string binaryBlock = ssBlock.str();\r\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\r\n-        req->WriteReply(HTTP_OK, binaryBlock);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, binaryBlock);\r\n         return true;\r\n     }\r\n \r\n@@ -257,7 +257,7 @@ static bool rest_block(HTTPRequest* req,\r\n         ssBlock << block;\r\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\r\n-        req->WriteReply(HTTP_OK, strHex);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strHex);\r\n         return true;\r\n     }\r\n \r\n@@ -265,12 +265,12 @@ static bool rest_block(HTTPRequest* req,\r\n         UniValue objBlock = blockToJSON(block, tip, pblockindex, showTxDetails);\r\n         std::string strJSON = objBlock.write() + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strJSON);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strJSON);\r\n         return true;\r\n     }\r\n \r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n     }\r\n     }\r\n }\r\n@@ -302,11 +302,11 @@ static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\r\n         UniValue chainInfoObject = getblockchaininfo(jsonRequest);\r\n         std::string strJSON = chainInfoObject.write() + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strJSON);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strJSON);\r\n         return true;\r\n     }\r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: json)\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: json)\");\r\n     }\r\n     }\r\n }\r\n@@ -326,11 +326,11 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\r\n \r\n         std::string strJSON = mempoolInfoObject.write() + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strJSON);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strJSON);\r\n         return true;\r\n     }\r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: json)\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: json)\");\r\n     }\r\n     }\r\n }\r\n@@ -349,11 +349,11 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\r\n \r\n         std::string strJSON = mempoolObject.write() + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strJSON);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strJSON);\r\n         return true;\r\n     }\r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: json)\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: json)\");\r\n     }\r\n     }\r\n }\r\n@@ -367,7 +367,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\r\n \r\n     uint256 hash;\r\n     if (!ParseHashStr(hashStr, hash))\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Invalid hash: \" + hashStr);\r\n \r\n     if (g_txindex) {\r\n         g_txindex->BlockUntilSyncedToCurrentChain();\r\n@@ -376,7 +376,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\r\n     CTransactionRef tx;\r\n     uint256 hashBlock = uint256();\r\n     if (!GetTransaction(hash, tx, Params().GetConsensus(), hashBlock))\r\n-        return RESTERR(req, HTTP_NOT_FOUND, hashStr + \" not found\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, hashStr + \" not found\");\r\n \r\n     switch (rf) {\r\n     case RetFormat::BINARY: {\r\n@@ -385,7 +385,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\r\n \r\n         std::string binaryTx = ssTx.str();\r\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\r\n-        req->WriteReply(HTTP_OK, binaryTx);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, binaryTx);\r\n         return true;\r\n     }\r\n \r\n@@ -395,7 +395,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\r\n \r\n         std::string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\r\n-        req->WriteReply(HTTP_OK, strHex);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strHex);\r\n         return true;\r\n     }\r\n \r\n@@ -404,12 +404,12 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\r\n         TxToUniv(*tx, hashBlock, objTx);\r\n         std::string strJSON = objTx.write() + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strJSON);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strJSON);\r\n         return true;\r\n     }\r\n \r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n     }\r\n     }\r\n }\r\n@@ -431,7 +431,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n     // throw exception in case of an empty request\r\n     std::string strRequestMutable = req->ReadBody();\r\n     if (strRequestMutable.length() == 0 && uriParts.size() == 0)\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Error: empty request\");\r\n \r\n     bool fInputParsed = false;\r\n     bool fCheckMemPool = false;\r\n@@ -453,7 +453,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n             std::string strOutput = uriParts[i].substr(uriParts[i].find('-')+1);\r\n \r\n             if (!ParseInt32(strOutput, &nOutput) || !IsHex(strTxid))\r\n-                return RESTERR(req, HTTP_BAD_REQUEST, \"Parse error\");\r\n+                return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Parse error\");\r\n \r\n             txid.SetHex(strTxid);\r\n             vOutPoints.push_back(COutPoint(txid, (uint32_t)nOutput));\r\n@@ -462,7 +462,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n         if (vOutPoints.size() > 0)\r\n             fInputParsed = true;\r\n         else\r\n-            return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\r\n+            return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Error: empty request\");\r\n     }\r\n \r\n     switch (rf) {\r\n@@ -478,7 +478,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n             if (strRequestMutable.size() > 0)\r\n             {\r\n                 if (fInputParsed) //don't allow sending input over URI and HTTP RAW DATA\r\n-                    return RESTERR(req, HTTP_BAD_REQUEST, \"Combination of URI scheme inputs and raw post data is not allowed\");\r\n+                    return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Combination of URI scheme inputs and raw post data is not allowed\");\r\n \r\n                 CDataStream oss(SER_NETWORK, PROTOCOL_VERSION);\r\n                 oss << strRequestMutable;\r\n@@ -487,24 +487,24 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n             }\r\n         } catch (const std::ios_base::failure&) {\r\n             // abort in case of unreadable binary data\r\n-            return RESTERR(req, HTTP_BAD_REQUEST, \"Parse error\");\r\n+            return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Parse error\");\r\n         }\r\n         break;\r\n     }\r\n \r\n     case RetFormat::JSON: {\r\n         if (!fInputParsed)\r\n-            return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\r\n+            return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Error: empty request\");\r\n         break;\r\n     }\r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n     }\r\n     }\r\n \r\n     // limit max outpoints\r\n     if (vOutPoints.size() > MAX_GETUTXOS_OUTPOINTS)\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, strprintf(\"Error: max outpoints exceeded (max: %d, tried: %d)\", MAX_GETUTXOS_OUTPOINTS, vOutPoints.size()));\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, strprintf(\"Error: max outpoints exceeded (max: %d, tried: %d)\", MAX_GETUTXOS_OUTPOINTS, vOutPoints.size()));\r\n \r\n     // check spentness and form a bitmap (as well as a JSON capable human-readable string representation)\r\n     std::vector<unsigned char> bitmap;\r\n@@ -551,7 +551,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n         std::string ssGetUTXOResponseString = ssGetUTXOResponse.str();\r\n \r\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\r\n-        req->WriteReply(HTTP_OK, ssGetUTXOResponseString);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, ssGetUTXOResponseString);\r\n         return true;\r\n     }\r\n \r\n@@ -561,7 +561,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n         std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\r\n \r\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\r\n-        req->WriteReply(HTTP_OK, strHex);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strHex);\r\n         return true;\r\n     }\r\n \r\n@@ -591,11 +591,11 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\r\n         // return json string\r\n         std::string strJSON = objGetUTXOResponse.write() + \"\\n\";\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n-        req->WriteReply(HTTP_OK, strJSON);\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, strJSON);\r\n         return true;\r\n     }\r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n     }\r\n     }\r\n }\r\n@@ -609,14 +609,14 @@ static bool rest_blockhash_by_height(HTTPRequest* req,\r\n \r\n     int32_t blockheight;\r\n     if (!ParseInt32(height_str, &blockheight) || blockheight < 0) {\r\n-        return RESTERR(req, HTTP_BAD_REQUEST, \"Invalid height: \" + SanitizeString(height_str));\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_BAD_REQUEST, \"Invalid height: \" + SanitizeString(height_str));\r\n     }\r\n \r\n     CBlockIndex* pblockindex = nullptr;\r\n     {\r\n         LOCK(cs_main);\r\n         if (blockheight > ::ChainActive().Height()) {\r\n-            return RESTERR(req, HTTP_NOT_FOUND, \"Block height out of range\");\r\n+            return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"Block height out of range\");\r\n         }\r\n         pblockindex = ::ChainActive()[blockheight];\r\n     }\r\n@@ -625,23 +625,23 @@ static bool rest_blockhash_by_height(HTTPRequest* req,\r\n         CDataStream ss_blockhash(SER_NETWORK, PROTOCOL_VERSION);\r\n         ss_blockhash << pblockindex->GetBlockHash();\r\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\r\n-        req->WriteReply(HTTP_OK, ss_blockhash.str());\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, ss_blockhash.str());\r\n         return true;\r\n     }\r\n     case RetFormat::HEX: {\r\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\r\n-        req->WriteReply(HTTP_OK, pblockindex->GetBlockHash().GetHex() + \"\\n\");\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, pblockindex->GetBlockHash().GetHex() + \"\\n\");\r\n         return true;\r\n     }\r\n     case RetFormat::JSON: {\r\n         req->WriteHeader(\"Content-Type\", \"application/json\");\r\n         UniValue resp = UniValue(UniValue::VOBJ);\r\n         resp.pushKV(\"blockhash\", pblockindex->GetBlockHash().GetHex());\r\n-        req->WriteReply(HTTP_OK, resp.write() + \"\\n\");\r\n+        req->WriteReply(HTTPStatusCode::HTTP_OK, resp.write() + \"\\n\");\r\n         return true;\r\n     }\r\n     default: {\r\n-        return RESTERR(req, HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n+        return RESTERR(req, HTTPStatusCode::HTTP_NOT_FOUND, \"output format not found (available: \" + AvailableDataFormatsString() + \")\");\r\n     }\r\n     }\r\n }\r\ndiff --git a/src/rpc/protocol.h b/src/rpc/protocol.h\r\nindex d1475f452..23d6e94b6 100644\r\n--- a/src/rpc/protocol.h\r\n+++ b/src/rpc/protocol.h\r\n@@ -7,7 +7,7 @@\r\n #define BITCOIN_RPC_PROTOCOL_H\r\n \r\n //! HTTP status codes\r\n-enum HTTPStatusCode\r\n+enum class HTTPStatusCode\r\n {\r\n     HTTP_OK                    = 200,\r\n     HTTP_BAD_REQUEST           = 400,\r\n```\r\n\r\n</details>",
      "created_at" : "2020-02-18T11:27:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-587415682",
      "id" : 587415682,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzQxNTY4Mg==",
      "updated_at" : "2020-02-18T11:27:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587415682",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@practicalswift your suggestion increases type safety therefore I like it. But the suggested change is logically independent from this change therefore I'd prefer to make a follow up PR for that.",
      "created_at" : "2020-02-18T11:36:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-587418648",
      "id" : 587418648,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzQxODY0OA==",
      "updated_at" : "2020-02-18T11:36:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587418648",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7702854?v=4",
         "events_url" : "https://api.github.com/users/toxeus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/toxeus/followers",
         "following_url" : "https://api.github.com/users/toxeus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/toxeus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/toxeus",
         "id" : 7702854,
         "login" : "toxeus",
         "node_id" : "MDQ6VXNlcjc3MDI4NTQ=",
         "organizations_url" : "https://api.github.com/users/toxeus/orgs",
         "received_events_url" : "https://api.github.com/users/toxeus/received_events",
         "repos_url" : "https://api.github.com/users/toxeus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/toxeus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/toxeus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/toxeus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK aff2748f8aee72f03b5fb6f6f97f0d0f66391755 -- patch looks correct",
      "created_at" : "2020-02-18T12:48:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-587443828",
      "id" : 587443828,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzQ0MzgyOA==",
      "updated_at" : "2020-02-18T12:48:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587443828",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'd rather we go the opposite direction, and adopt libevent's macros (eliminating our own).\r\n\r\nIs there a reason to have our own duplicated macros? Or are they just holdovers from the pre-libevent implementation?",
      "created_at" : "2020-02-19T03:47:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-588021176",
      "id" : 588021176,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODAyMTE3Ng==",
      "updated_at" : "2020-02-19T03:47:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588021176",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@laanwj added the enum in 2012 (285746d3dbed46d0e444d7a907c08453d36d99cd) which is before the introduction of evhttpd (40b556d3742a1f65d67e2d4c760d0b13fe8be5b7). I'm fine with eliminating the enums and using the libevent macros. Maybe @laanwj has an opinion on this?",
      "created_at" : "2020-02-19T05:03:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-588037155",
      "id" : 588037155,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODAzNzE1NQ==",
      "updated_at" : "2020-02-19T05:03:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588037155",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7702854?v=4",
         "events_url" : "https://api.github.com/users/toxeus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/toxeus/followers",
         "following_url" : "https://api.github.com/users/toxeus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/toxeus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/toxeus",
         "id" : 7702854,
         "login" : "toxeus",
         "node_id" : "MDQ6VXNlcjc3MDI4NTQ=",
         "organizations_url" : "https://api.github.com/users/toxeus/orgs",
         "received_events_url" : "https://api.github.com/users/toxeus/received_events",
         "repos_url" : "https://api.github.com/users/toxeus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/toxeus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/toxeus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/toxeus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "In general, enums confer more type information, passing more information further down into the compile pipeline, vs macros.   All other things being equal, that lends weight to a enums>macros preference, for greater -O0 debug-ability -- symbol names in gdb, vs numbers -- as well as greater type clarity & safety.",
      "created_at" : "2020-02-19T06:08:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-588052836",
      "id" : 588052836,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODA1MjgzNg==",
      "updated_at" : "2020-02-19T06:08:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588052836",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/494411?v=4",
         "events_url" : "https://api.github.com/users/jgarzik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jgarzik/followers",
         "following_url" : "https://api.github.com/users/jgarzik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jgarzik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jgarzik",
         "id" : 494411,
         "login" : "jgarzik",
         "node_id" : "MDQ6VXNlcjQ5NDQxMQ==",
         "organizations_url" : "https://api.github.com/users/jgarzik/orgs",
         "received_events_url" : "https://api.github.com/users/jgarzik/received_events",
         "repos_url" : "https://api.github.com/users/jgarzik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jgarzik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jgarzik"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Agree with @jgarzik.\r\n\r\nThis is what the C++ Core Guidelines has to say:\r\n\r\n* [`enum class` is strictly better than plain `enum`](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#enum3-prefer-class-enums-over-plain-enums)\r\n* [Plain `enum` is strictly better than macro (`#define`)](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#enum1-prefer-enumerations-over-macros)\r\n* Macro (`#define`) is strictly better than magic number\r\n\r\n",
      "created_at" : "2020-02-19T13:15:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-588223444",
      "id" : 588223444,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODIyMzQ0NA==",
      "updated_at" : "2020-02-19T13:15:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588223444",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "If we go with `enum` over libevent macros, why not also change type to `HTTPStatusCode` everywhere (for example, line `int nStatus = HTTP_INTERNAL_SERVER_ERROR;` in `src/httprpc.cpp`)?",
      "created_at" : "2020-02-21T00:34:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-589441233",
      "id" : 589441233,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTQ0MTIzMw==",
      "updated_at" : "2020-02-21T00:34:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589441233",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/4500994?v=4",
         "events_url" : "https://api.github.com/users/kristapsk/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kristapsk/followers",
         "following_url" : "https://api.github.com/users/kristapsk/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kristapsk/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kristapsk",
         "id" : 4500994,
         "login" : "kristapsk",
         "node_id" : "MDQ6VXNlcjQ1MDA5OTQ=",
         "organizations_url" : "https://api.github.com/users/kristapsk/orgs",
         "received_events_url" : "https://api.github.com/users/kristapsk/received_events",
         "repos_url" : "https://api.github.com/users/kristapsk/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kristapsk/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kristapsk/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kristapsk"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@promag your statement is self-contradictory. The enum in discussion is in `#include <rpc/protocol.h>`.",
      "created_at" : "2020-02-21T07:50:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-589539354",
      "id" : 589539354,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTUzOTM1NA==",
      "updated_at" : "2020-02-21T07:50:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589539354",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7702854?v=4",
         "events_url" : "https://api.github.com/users/toxeus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/toxeus/followers",
         "following_url" : "https://api.github.com/users/toxeus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/toxeus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/toxeus",
         "id" : 7702854,
         "login" : "toxeus",
         "node_id" : "MDQ6VXNlcjc3MDI4NTQ=",
         "organizations_url" : "https://api.github.com/users/toxeus/orgs",
         "received_events_url" : "https://api.github.com/users/toxeus/received_events",
         "repos_url" : "https://api.github.com/users/toxeus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/toxeus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/toxeus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/toxeus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@toxeus yes I know, I think it should be in `src/httpserver.h`, where it's needed by `WriteReply()`. Also sounds weird including a rpc header in httpserver code, should be the other way around.",
      "created_at" : "2020-02-21T08:00:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-589542197",
      "id" : 589542197,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTU0MjE5Nw==",
      "updated_at" : "2020-02-21T08:00:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589542197",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Makes sense. Thanks for clarifying :+1: ",
      "created_at" : "2020-02-21T08:01:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-589542597",
      "id" : 589542597,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTU0MjU5Nw==",
      "updated_at" : "2020-02-21T08:01:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589542597",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7702854?v=4",
         "events_url" : "https://api.github.com/users/toxeus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/toxeus/followers",
         "following_url" : "https://api.github.com/users/toxeus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/toxeus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/toxeus",
         "id" : 7702854,
         "login" : "toxeus",
         "node_id" : "MDQ6VXNlcjc3MDI4NTQ=",
         "organizations_url" : "https://api.github.com/users/toxeus/orgs",
         "received_events_url" : "https://api.github.com/users/toxeus/received_events",
         "repos_url" : "https://api.github.com/users/toxeus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/toxeus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/toxeus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/toxeus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "HTTP status codes aren't really an enum, though...",
      "created_at" : "2020-02-21T13:01:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-589643810",
      "id" : 589643810,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTY0MzgxMA==",
      "updated_at" : "2020-02-21T13:01:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589643810",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> HTTP status codes aren't really an enum, though...\r\n\r\nenums are used often beyond the strict semantics you're referring to. They group constants together that belong together. enum classes even add type safety. The fact that the HTTP status codes are defined in an enum since years and nobody seemed to care supports my argument I think.\r\n\r\nStill, I'm also not happy about duplicating here something that is also defined in libevent. OTOH, the added type safety and improved code readability do justify a duplication using an enum class.",
      "created_at" : "2020-02-27T08:38:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18168#issuecomment-591849227",
      "id" : 591849227,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18168",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5MTg0OTIyNw==",
      "updated_at" : "2020-02-27T08:38:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/591849227",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7702854?v=4",
         "events_url" : "https://api.github.com/users/toxeus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/toxeus/followers",
         "following_url" : "https://api.github.com/users/toxeus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/toxeus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/toxeus",
         "id" : 7702854,
         "login" : "toxeus",
         "node_id" : "MDQ6VXNlcjc3MDI4NTQ=",
         "organizations_url" : "https://api.github.com/users/toxeus/orgs",
         "received_events_url" : "https://api.github.com/users/toxeus/received_events",
         "repos_url" : "https://api.github.com/users/toxeus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/toxeus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/toxeus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/toxeus"
      }
   }
]
