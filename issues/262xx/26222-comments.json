[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1368140182), [hebasto](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424459844), [pinheadmz](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424673767) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "created_at" : "2022-10-01T19:02:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1264453668",
      "id" : 1264453668,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585LXggk",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1264453668/reactions"
      },
      "updated_at" : "2023-05-12T17:40:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1264453668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145050"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050"
         }
      },
      "author_association" : "NONE",
      "body" : "I'm curious as to why the return value isnt self - a?\r\nis it because this function calls the previously declared  `__add__ ` and requires a negative input to evaluate properly?\r\nor (-a) is calling the `__mul__`",
      "commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "created_at" : "2022-10-01T21:09:48Z",
      "diff_hunk" : "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145050",
      "id" : 985145050,
      "line" : 218,
      "node_id" : "PRRC_kwDOABII5846uB7a",
      "original_commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "original_line" : 218,
      "original_position" : 375,
      "original_start_line" : 214,
      "path" : "test/functional/test_framework/key.py",
      "position" : 375,
      "pull_request_review_id" : 1127567653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 214,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-01T21:15:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/45839100?v=4",
         "events_url" : "https://api.github.com/users/amovfx/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amovfx/followers",
         "following_url" : "https://api.github.com/users/amovfx/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amovfx/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amovfx",
         "id" : 45839100,
         "login" : "amovfx",
         "node_id" : "MDQ6VXNlcjQ1ODM5MTAw",
         "organizations_url" : "https://api.github.com/users/amovfx/orgs",
         "received_events_url" : "https://api.github.com/users/amovfx/received_events",
         "repos_url" : "https://api.github.com/users/amovfx/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amovfx/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amovfx/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amovfx"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`self - a` would just trigger infinite recursion, as it's equivalent to `self.__sub__(a)`.\r\n\r\nWriting `self + (-a)` on the other hand is `self.__add__(a.__neg__())`.\r\n\r\nThere is no \"negative input\"; these objects represent field elements (integers modulo 2^256 - 2^32 - 977), which have no concept of positive/negative. This function is implementing how to compute `self - a`; we do that by adding `self` to the negation of `a`.",
      "commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "created_at" : "2022-10-01T21:18:22Z",
      "diff_hunk" : "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145867",
      "id" : 985145867,
      "in_reply_to_id" : 985145050,
      "line" : 218,
      "node_id" : "PRRC_kwDOABII5846uCIL",
      "original_commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "original_line" : 218,
      "original_position" : 375,
      "original_start_line" : 214,
      "path" : "test/functional/test_framework/key.py",
      "position" : 375,
      "pull_request_review_id" : 1127568198,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 214,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-01T21:47:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2022-12-13T16:22:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1348977342",
      "id" : 1348977342,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585QZ8K-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1348977342/reactions"
      },
      "updated_at" : "2022-12-13T16:22:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1348977342",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1055283752"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "shouldn't this be `b.num`?",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2022-12-22T09:53:59Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1055283752",
      "id" : 1055283752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584-5loo",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 44,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1227403349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T19:57:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1060520793"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "i didn't understand how `n = (self.num * self.den) % FE.SIZE`?\r\n(and not `n = int(self) % FE.SIZE`)",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-03T12:01:42Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1060520793",
      "id" : 1060520793,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII584_NkNZ",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 134,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 194,
      "pull_request_review_id" : 1227403349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T19:57:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-01-03T22:20:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1370283260",
      "id" : 1370283260,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585RrNz8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1370283260/reactions"
      },
      "updated_at" : "2023-01-03T22:20:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1370283260",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed. Fixed!",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-04T20:20:28Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852160",
      "id" : 1061852160,
      "in_reply_to_id" : 1055283752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584_SpQA",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 44,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1236432569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T20:20:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah!\r\n\r\nThe squareness of `num/den` = `(num*den) / den^2` is the same as that of `num*den`, because they're related by a factor `den^2`, which is always square.\r\n\r\nI've added a comment to clarify.",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-04T20:21:40Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852938",
      "id" : 1061852938,
      "in_reply_to_id" : 1060520793,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII584_SpcK",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 134,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 194,
      "pull_request_review_id" : 1236433777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T20:21:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1154452161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's a typo I guess?\r\n```suggestion\r\n        raising the argument to the power (p + 1) / 4.\r\n```",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-03-31T13:04:54Z",
      "diff_hunk" : "@@ -25,258 +25,348 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1154452161",
      "id" : 1154452161,
      "line" : 113,
      "node_id" : "PRRC_kwDOABII585Ez4rB",
      "original_commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "original_line" : 113,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 173,
      "pull_request_review_id" : 1366903430,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-31T13:12:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-04-28T10:44:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1527373023",
      "id" : 1527373023,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585bCdzf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1527373023/reactions"
      },
      "updated_at" : "2023-04-28T10:44:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1527373023",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192016465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice catch, fixed.",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-12T07:35:03Z",
      "diff_hunk" : "@@ -25,258 +25,348 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192016465",
      "id" : 1192016465,
      "in_reply_to_id" : 1154452161,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585HDLpR",
      "original_commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "original_line" : 111,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1423941466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-12T07:35:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@theStack I've included your commit to add the precomputed G table. The speedup is significant enough that it's worth it, I think.\r\n\r\nYou've indeed discovered one of the techniques that are used for speeding up EC multiplications with precomputed tables. Libsecp256k1 today uses a more advanced version of that idea, where all multiples of the form `i*16^j*G` for all i=0..15, and j=0..63 are precomputed, leaving us with ~63 point additions. An even more advanced approach is discussed in https://github.com/bitcoin-core/secp256k1/pull/1058, if you're interested. All of that is IMO out of scope for the test framework, though.",
      "created_at" : "2023-05-12T07:39:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1545314256",
      "id" : 1545314256,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cG5_Q",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545314256/reactions"
      },
      "updated_at" : "2023-05-12T07:41:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545314256",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "cc @real-or-random ",
      "created_at" : "2023-05-12T08:48:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1545399444",
      "id" : 1545399444,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cHOyU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545399444/reactions"
      },
      "updated_at" : "2023-05-12T08:48:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545399444",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192479969"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not using hex here?",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-12T14:53:38Z",
      "diff_hunk" : "@@ -23,258 +23,350 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        if self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        # Adding point to its negation\n+        return None\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Subtract a point from infinity.\"\"\"\n+        assert a is None\n+        return -a\n+\n+    def __mul__(self, a):\n+        \"\"\"Multiply a point with an integer (scalar multiplication).\"\"\"\n+        if self == SECP256K1_G:  # optimize generator multiplication using precomputed data\n+            return fast_g.mul(a)\n+        r = None\n+        for i in range(a.bit_length() - 1, -1, -1):\n+            if r is not None:\n+                r = r.double()\n+            if (a >> i) & 1:\n+                r += self\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a point (scalar multiplication).\"\"\"\n+        return self * a\n+\n+    @staticmethod\n+    def mmul(*ps):\n+        \"\"\"Compute a (multi) point multiplication.\n+\n+        mmul((p1, a1), (p2, a2), (p3, a3)) is identical to p1*a1 + p2*a2 + p3*a3,\n+        but more efficient.\"\"\"\n+        r = None\n         for i in range(255, -1, -1):\n-            r = self.double(r)\n+            if r is not None:\n+                r = r.double()\n             for (p, n) in ps:\n                 if ((n >> i) & 1):\n-                    r = self.add(r, p)\n+                    r += p\n         return r\n \n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a point.\"\"\"\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a point to 33-byte compressed encoding.\"\"\"\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a point to 65-byte uncompressed encoding.\"\"\"\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the X coordinate of) a point to 32-byte xonly encoding.\"\"\"\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Take an FE, and return the point with that as X coordinate, and even Y.\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a point.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a point.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        return f\"({self.x},{self.y})\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192479969",
      "id" : 1192479969,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585HE8zh",
      "original_commit_id" : "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "original_line" : 328,
      "original_position" : 496,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 495,
      "pull_request_review_id" : 1424673767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-12T15:57:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2084648?v=4",
         "events_url" : "https://api.github.com/users/pinheadmz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pinheadmz/followers",
         "following_url" : "https://api.github.com/users/pinheadmz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pinheadmz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pinheadmz",
         "id" : 2084648,
         "login" : "pinheadmz",
         "node_id" : "MDQ6VXNlcjIwODQ2NDg=",
         "organizations_url" : "https://api.github.com/users/pinheadmz/orgs",
         "received_events_url" : "https://api.github.com/users/pinheadmz/received_events",
         "repos_url" : "https://api.github.com/users/pinheadmz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pinheadmz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pinheadmz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pinheadmz"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192653577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "it's defined by `FE` as hex, so should be fine?",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-12T17:53:31Z",
      "diff_hunk" : "@@ -23,258 +23,350 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        if self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        # Adding point to its negation\n+        return None\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Subtract a point from infinity.\"\"\"\n+        assert a is None\n+        return -a\n+\n+    def __mul__(self, a):\n+        \"\"\"Multiply a point with an integer (scalar multiplication).\"\"\"\n+        if self == SECP256K1_G:  # optimize generator multiplication using precomputed data\n+            return fast_g.mul(a)\n+        r = None\n+        for i in range(a.bit_length() - 1, -1, -1):\n+            if r is not None:\n+                r = r.double()\n+            if (a >> i) & 1:\n+                r += self\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a point (scalar multiplication).\"\"\"\n+        return self * a\n+\n+    @staticmethod\n+    def mmul(*ps):\n+        \"\"\"Compute a (multi) point multiplication.\n+\n+        mmul((p1, a1), (p2, a2), (p3, a3)) is identical to p1*a1 + p2*a2 + p3*a3,\n+        but more efficient.\"\"\"\n+        r = None\n         for i in range(255, -1, -1):\n-            r = self.double(r)\n+            if r is not None:\n+                r = r.double()\n             for (p, n) in ps:\n                 if ((n >> i) & 1):\n-                    r = self.add(r, p)\n+                    r += p\n         return r\n \n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a point.\"\"\"\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a point to 33-byte compressed encoding.\"\"\"\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a point to 65-byte uncompressed encoding.\"\"\"\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the X coordinate of) a point to 32-byte xonly encoding.\"\"\"\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Take an FE, and return the point with that as X coordinate, and even Y.\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a point.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a point.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        return f\"({self.x},{self.y})\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192653577",
      "id" : 1192653577,
      "in_reply_to_id" : 1192479969,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585HFnMJ",
      "original_commit_id" : "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "original_line" : 328,
      "original_position" : 496,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 495,
      "pull_request_review_id" : 1424936684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-12T17:53:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reads fine to me from my not-even-cryptographer-on-tv level of understanding.\r\n\r\nGoes from 27 to 31 seconds on my machine with the precomputed table, which is very easy to understand. Without the table it hikes up to 53 seconds.",
      "created_at" : "2023-05-12T18:15:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1546111610",
      "id" : 1546111610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cJ8p6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546111610/reactions"
      },
      "updated_at" : "2023-05-12T18:15:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546111610",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "outdated comment",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-13T08:34:57Z",
      "diff_hunk" : "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949389",
      "id" : 1192949389,
      "line" : 179,
      "node_id" : "PRRC_kwDOABII585HGvaN",
      "original_commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "original_line" : 179,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 339,
      "pull_request_review_id" : 1425361344,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-13T08:38:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949775"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This one too. I suggest iterating over the all doc comments, also to make \"group element\" vs \"point\" consistent. (`__repr__` uses group element.)",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-13T08:38:27Z",
      "diff_hunk" : "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        if self.infinity:\n+            return self\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949775",
      "id" : 1192949775,
      "line" : 207,
      "node_id" : "PRRC_kwDOABII585HGvgP",
      "original_commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "original_line" : 207,
      "original_position" : 367,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 367,
      "pull_request_review_id" : 1425361344,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-13T08:38:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   }
]
