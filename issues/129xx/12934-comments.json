[
   {
      "author_association" : "MEMBER",
      "body" : "cc @theuni\r\n@skeees Have you looked through the current work being done to refactor the P2P code? See [here](https://github.com/bitcoin/bitcoin/projects/4) for an overview.",
      "created_at" : "2018-04-11T04:28:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-380323422",
      "id" : 380323422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-11T04:29:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380323422",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Thanks, yes I have looked through those. This is more focused on separation between net_processing (PeerLogicValidation) and validation, whereas those primarily tackle socket handling and other ConnMan stuff. I don't think there's anything here that's redundant or incompatible with those refactors",
      "created_at" : "2018-04-11T13:27:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-380451284",
      "id" : 380451284,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-11T13:27:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380451284",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "cc @TheBlueMatt ",
      "created_at" : "2018-04-13T02:26:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-381001882",
      "id" : 381001882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-13T02:26:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/381001882",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183498792"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183498792"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think you could replace this class with `using WorkItem = std::function<void()>;`. Less code and would make queue interface more generic.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-04-23T18:44:01Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183498792",
      "id" : 183498792,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzQ5ODc5Mg==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 17,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183498792",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183500740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183500740"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could maybe use TraceThread from util.h to make the thread name visible to the os.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-04-23T18:50:50Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template<WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE> {\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer) {};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if(std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if(!m_threads_observed.count(id) || 0) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                ShutdownPill * copy = new ShutdownPill(std::move(*this));\n+                m_consumer.m_queue->Push(std::unique_ptr<ShutdownPill>(copy), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE> &m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template<WorkerMode PRODUCER_MODE>\n+using WorkQueue = BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>,PRODUCER_MODE>;\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template<WorkerMode PRODUCER_POLICY>\n+class ConsumerThread {\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() :m_active(false) {};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"\")\n+        :m_id(id), m_queue(queue), m_active(true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183500740",
      "id" : 183500740,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwMDc0MA==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 88,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183500740",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183502878"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183502878"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ShutdownPill seems a little complicated. What advantages does it provide over just adding `bool m_active` to  `ProducerConsumerQueue` with a simple method to set it to false and cancel blocked Pop() calls?",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-04-23T18:58:05Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template<WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE> {\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer) {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183502878",
      "id" : 183502878,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwMjg3OA==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 32,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183502878",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183505818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183505818"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could use make_shared here, MakeUnique below",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-04-23T19:09:03Z",
      "diff_hunk" : "@@ -0,0 +1,106 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+class ValidationLayer;\n+\n+template<typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING> {\n+    friend class ValidationLayer;\n+protected:\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+struct BlockValidationResponse {\n+    const bool is_new;\n+    const bool not_immediately_invalid;\n+\n+    BlockValidationResponse(bool _not_immediately_invalid, bool _is_new)\n+      :is_new(_is_new), not_immediately_invalid(_not_immediately_invalid) {};\n+};\n+\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse> {\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+    :m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready) {};\n+\n+    void operator()();\n+\n+    const ValidationLayer& m_validation_layer;\n+    const std::shared_ptr<const CBlock> m_block;\n+    const bool m_force_processing;\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block and header validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: Submitforvalidation(object) -> future<Response>\n+ *  - synchronous: Validate(object) -> Response\n+ * object may be a block or block header\n+ */\n+class ValidationLayer {\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        :m_chainparams(chainparams), m_validation_queue(std::shared_ptr<ValidationQueue>(new ValidationQueue(100))) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183505818",
      "id" : 183505818,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwNTgxOA==",
      "original_commit_id" : "c10466c7a25a3b38c0e81337f56ab5fa59ac4bef",
      "original_position" : 62,
      "path" : "src/validation_layer.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183505818",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183507013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183507013"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Probably should take unique_ptr instead of raw argument to clarify ownership",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-04-23T19:13:22Z",
      "diff_hunk" : "@@ -0,0 +1,106 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+class ValidationLayer;\n+\n+template<typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING> {\n+    friend class ValidationLayer;\n+protected:\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+struct BlockValidationResponse {\n+    const bool is_new;\n+    const bool not_immediately_invalid;\n+\n+    BlockValidationResponse(bool _not_immediately_invalid, bool _is_new)\n+      :is_new(_is_new), not_immediately_invalid(_not_immediately_invalid) {};\n+};\n+\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse> {\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+    :m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready) {};\n+\n+    void operator()();\n+\n+    const ValidationLayer& m_validation_layer;\n+    const std::shared_ptr<const CBlock> m_block;\n+    const bool m_force_processing;\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block and header validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: Submitforvalidation(object) -> future<Response>\n+ *  - synchronous: Validate(object) -> Response\n+ * object may be a block or block header\n+ */\n+class ValidationLayer {\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        :m_chainparams(chainparams), m_validation_queue(std::shared_ptr<ValidationQueue>(new ValidationQueue(100))) {}\n+\n+    ~ValidationLayer() {};\n+\n+    void Start()\n+    {\n+        assert(!m_thread || !m_thread->IsActive());\n+        m_thread = std::unique_ptr<ValidationThread>(new ValidationThread(m_validation_queue));\n+    };\n+\n+    void Stop()\n+    {\n+        assert(m_thread);\n+        m_thread->Terminate();\n+    };\n+\n+    std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready=[](){})\n+    {\n+        BlockValidationRequest * req = new BlockValidationRequest(*this, block, force_processing, on_ready);\n+        return SubmitForValidation<BlockValidationResponse>(req);\n+    };\n+\n+    BlockValidationResponse Validate(const std::shared_ptr<const CBlock> block, bool force_processing) const\n+    {\n+        bool is_new = false;\n+        bool block_valid = ProcessNewBlock(m_chainparams, block, force_processing, &is_new);\n+        return BlockValidationResponse(block_valid, is_new);\n+    };\n+\n+ private:\n+    template<typename RESPONSE>\n+    std::future<RESPONSE> SubmitForValidation(ValidationRequest<RESPONSE> * request)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183507013",
      "id" : 183507013,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwNzAxMw==",
      "original_commit_id" : "c10466c7a25a3b38c0e81337f56ab5fa59ac4bef",
      "original_position" : 93,
      "path" : "src/validation_layer.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183507013",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thank you for the review - one thing (general design related) to add to the discussion here:\r\n\r\nSince I've submitted this request - I happened to stumble upon two race conditions in validation that stem from concurrent calls to ProcessNewBlock (#12988, #13023) \r\nThis pr should simplify the concurrency model for block validation (a single validation thread pulls a block to validate from the queue and validates it completely before moving on to the next block) and would have inadvertently fixed those two referenced race conditions.\r\n\r\nExplicitly simplifying the concurrency model hopefully reduces a bit the cognitive burden of future code changes in validation and I don't think makes anything substantially less efficient - much of validation is already single threaded (because of cs_main), and certain pieces fundamentally cannot be concurrent (i.e. connecttip). Validation is already complicated enough to understand on its own without worrying about concurrency.\r\n\r\nSeems like the clarity gains will outweigh the minor efficiency hit here - +the async api into should allow all the stuff around validation to be more easily be parallelized with less risk of inadvertently introducing a consensus bug. And it makes process separation / alternate p2p more natural if that's ever to be a thing in the future.\r\n\r\nIf this design seems useful - my intention is to finish this pr up (some stuff around compact blocks that I still have to work through + refit the couple of places in rpc that call ProcessNewBlock) and explore subsequent prs to put a similar model in place around the mempool. I'd also like to explore feasibility for header processing.",
      "created_at" : "2018-04-23T22:52:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-383747761",
      "id" : 383747761,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-23T22:52:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383747761",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183562777"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183562777"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah - it is pretty complicated. I didn't want to poke through the queue api just to enable shutdown - you'd have to have `T Pop()` potentially not return a `T` (i.e. throw an exception) - which seemed less desirable and maybe equally complicated.\r\n\r\nHaving said that - a lot of the complexity here is introduced to handle:\r\n- being able to shutdown a specific ConsumerThread without shutting down others (in reality you probably only ever want to shut down all of them when you terminate the process)\r\n- allowing for a queue with fewer slots than the number of threads servicing it (unlikely)\r\n\r\nOnly reason I allowed for these is so that the APIs to the queue work the way they sound like they should work and for unit test completeness. If I discard the above the code gets much simpler and it will just be broken for two use cases that seem pretty unlikely to ever happen right now (but you never know - and then maybe somebody gets frustrated one day).",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-04-23T23:03:21Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template<WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE> {\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer) {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183562777",
      "id" : 183562777,
      "in_reply_to_id" : 183502878,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzU2Mjc3Nw==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 32,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114585105,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183562777",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I do think the general approach is fine. It's not going to be really at all useful until we do a ton of locking cleanups in net_processing (it'll let us run ahead to the next message, which almost always requires cs_main, and we'll end up blocking on validation anyway). It's probably simpler than multiple net_processing threads (with the same cleanups required) which was most of my previous work, but they'll end up looking pretty similar on the net_processing end, we were gonna need this blocking-on-response logic either way. Should definitely get brought up at a meeting, though, to get wider feedback. @theuni probably has some thoughts, too.",
      "created_at" : "2018-04-28T01:57:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-385131498",
      "id" : 385131498,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-28T01:57:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/385131498",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "PR updated with latest commits, ready for review\r\nAlso, for reference, a discussion on high level design for this PR at the IRC meeting a couple weeks ago:\r\nhttps://bitcoincore.org/en/meetings/2018/05/03/\r\n",
      "created_at" : "2018-06-05T11:54:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-394681515",
      "id" : 394681515,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NDY4MTUxNQ==",
      "updated_at" : "2018-06-05T11:54:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/394681515",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r195502312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195502312"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement a thread-safe FIFO (producer/consumer style) queue\" (d8106146e7511837decb4b45de35dec654454b69)\r\n\r\nShould probably emplace_back to avoid creating a temporary.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-06-14T17:11:53Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r195502312",
      "id" : 195502312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTUwMjMxMg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 81,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 81,
      "pull_request_review_id" : 128885288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195502312",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-06-15T20:08:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-397728959",
      "id" : 397728959,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NzcyODk1OQ==",
      "updated_at" : "2018-06-15T20:08:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/397728959",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196532632"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196532632"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement a thread-safe FIFO (producer/consumer style) queue\" (d8106146e7511837decb4b45de35dec654454b69)\r\n\r\nI don't think it's a good idea for blocking and nonblocking defaults to be attributes of the Queue data structure, instead of arguments to (or variants of) the push and pop methods. Advantages to dropping these template arguments:\r\n\r\n1) Readability. It would be nice to be able to see if a push or pop call is blocking just by looking at the call, without have to check another part of the code to see how the queue data structure was initially declared.\r\n2) Code size. Dropping these arguments would avoid compiler potentially having to instantiate many copies of this code for different combinations of template arguments.\r\n3) Extensibility. There could be other useful blocking methods added in the future (like methods to wait for low/high water marks or for empty/full events) and it would either be verbose to have to add new classwide blocking/nonblocking defaults for new methods, or confusing to have to somehow tie existing defaults to new methods.\r\n4) Consistency. If you look at other C++ objects that support optional blocking like std::mutex or std::future, the blocking behaviour is determined only by the particular method call, not by template arguments from where the object was declared.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-06-19T18:28:51Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196532632",
      "id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NjUzMjYzMg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 128885288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196532632",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196533649"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196533649"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement a thread-safe FIFO (producer/consumer style) queue\" (d8106146e7511837decb4b45de35dec654454b69)\r\n\r\nCould return std::future\\<T> in the case of a non-blocking Pop() to support it instead of having this asymmetry.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-06-19T18:32:02Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));\n+        }\n+        m_consumer_cv.notify_one();\n+        return true;\n+    };\n+\n+    /**\n+     * Try to pop the oldest element from the front of the queue, if present\n+     * Blocking consumer mode: will always eventually succeed\n+     * Nonblocking consumer mode: Pop() returns failure when the queue is empty\n+     * @param[out] the data popped, if the operation was successful\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    bool Pop(T& data, WorkerMode mode = m_consumer_mode)\n+    {\n+        // attempting a pop from a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() <= 0) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_consumer_cv.wait(l, [&]() { return m_data.size() > 0; });\n+            }\n+\n+            data = std::move(m_data.front());\n+            m_data.pop_front();\n+        }\n+        m_producer_cv.notify_one();\n+        return true;\n+    }\n+\n+    /**\n+     * Shortcut for bool Pop(T&) when consumer mode is blocking\n+     * This must always succeed and thus may only be called in producer blocking mode\n+     * @return the element popped\n+     */\n+    T Pop()\n+    {\n+        static_assert(m_consumer_mode == WorkerMode::BLOCKING, \"\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196533649",
      "id" : 196533649,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NjUzMzY0OQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 124,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 124,
      "pull_request_review_id" : 128885288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196533649",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199506587"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199506587"
         }
      },
      "author_association" : "MEMBER",
      "body" : "not sure i completely understand - data is already constructed when it is passed into the function - thought the most economical thing to do was std::forward which should use the move constructor when possible? is that different from what emplace_back would do?",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-02T13:59:22Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199506587",
      "id" : 199506587,
      "in_reply_to_id" : 195502312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUwNjU4Nw==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 81,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 81,
      "pull_request_review_id" : 133637301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199506587",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508335"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Doing that would complicate internal implementation a bit - you'd have to hang on to the promise that satisfies the future internally - and either you'd have too many of those and need to block - or potentially allow your buffer holding promises to grow unbounded - so actually it might not be safely implementable. \r\n\r\nAlso I don't really see an immediate use case for this - you'd have to later wait on the future (blocking or non-blocking) - but you could just alternately wait on the queue. I can't think of any use cases right now where you'd want to reserve a place in line in a non-blocking fashion and then later claim that item.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-02T14:04:56Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));\n+        }\n+        m_consumer_cv.notify_one();\n+        return true;\n+    };\n+\n+    /**\n+     * Try to pop the oldest element from the front of the queue, if present\n+     * Blocking consumer mode: will always eventually succeed\n+     * Nonblocking consumer mode: Pop() returns failure when the queue is empty\n+     * @param[out] the data popped, if the operation was successful\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    bool Pop(T& data, WorkerMode mode = m_consumer_mode)\n+    {\n+        // attempting a pop from a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() <= 0) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_consumer_cv.wait(l, [&]() { return m_data.size() > 0; });\n+            }\n+\n+            data = std::move(m_data.front());\n+            m_data.pop_front();\n+        }\n+        m_producer_cv.notify_one();\n+        return true;\n+    }\n+\n+    /**\n+     * Shortcut for bool Pop(T&) when consumer mode is blocking\n+     * This must always succeed and thus may only be called in producer blocking mode\n+     * @return the element popped\n+     */\n+    T Pop()\n+    {\n+        static_assert(m_consumer_mode == WorkerMode::BLOCKING, \"\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508335",
      "id" : 199508335,
      "in_reply_to_id" : 196533649,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUwODMzNQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 124,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 124,
      "pull_request_review_id" : 133639425,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508335",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508852"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I can see this either way - i wrote it with defaults essentially as constructor args because - at least for the use cases i can imagine you almost always want a default mode of operation for a given queue except for certain edge cases (shutdown is the most apparent one) - and i've seen data structures that handle this sort of initialization both ways (defaults on construction vs with every method call) but i'm also happy to change this up if the prevailing opinion is the other way.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-02T14:06:33Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508852",
      "id" : 199508852,
      "in_reply_to_id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUwODg1Mg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 133640052,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508852",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199527845"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199527845"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Talked about this offline with @ryanofsky, @skeees; this form is equivalent (in terms of constructor calls) to what @ryanofsky initially suggested so no need to change.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-02T15:03:42Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199527845",
      "id" : 199527845,
      "in_reply_to_id" : 195502312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUyNzg0NQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 81,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 81,
      "pull_request_review_id" : 133663218,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199527845",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199757735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199757735"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMight be nice to use vector\\<unique_ptr\\<Q>> to make this code exception safe and avoid need for manual deletion.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T10:25:19Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199757735",
      "id" : 199757735,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc1NzczNQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 90,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 90,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199757735",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199768981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199768981"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe give this function a more descriptive name like `PushThenPop`.\r\n\r\nMaybe add a summary comment like \"Push \\`elements_pushed\\` consecutive ints to the \r\n\\`push\\` queue, starting from (id * elements_to_values). Then pop \\`elements_pushed\\` values from the \\`recv\\` queue and verify all ints in the range (-elements_pushed, 0] are received, in any order.\"",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T11:13:13Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199768981",
      "id" : 199768981,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc2ODk4MQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 21,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 21,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199768981",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199770536"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199770536"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe give this function a more descriptive name like `PopAndPush`.\r\n\r\nMaybe add a summary comment like \"Pop \\`elements_pushed\\` values from the \\`work\\` queue. For each value \\`w\\` received, push value -(w % bucket_size) to the push[w / bucket_size] output queue.\"\r\n",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T11:19:35Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199770536",
      "id" : 199770536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc3MDUzNg==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 54,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 54,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199770536",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199772365"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199772365"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nIt could be nice to avoid this encoding (and the negative int encoding) by declaring a simple struct like:\r\n\r\n```c++\r\nstruct TestValue { int producer_id; int value; };\r\n```\r\n\r\nand using `ProducerConsumerQueue<TestValue>` in the test.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T11:28:09Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199772365",
      "id" : 199772365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc3MjM2NQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 63,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 63,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199772365",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199775175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199775175"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nSeems like this could more specifically assert (latest == -1) or (i == latest + 1). But perhaps the current way is more compact or less fragile.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T11:40:15Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199775175",
      "id" : 199775175,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc3NTE3NQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 66,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 66,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199775175",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199781485"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199781485"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe add a simple test description like \"Test simple queue pushes and pops which don't block.\"",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T12:05:58Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;\n+    for (int i = 0; i < n_producers; i++)\n+        pull.push_back(new Q(bucket_size));\n+\n+    boost::thread_group test_threads;\n+\n+    for (int i = 0; i < n_producers; i++) {\n+        test_threads.create_thread([&, i] { Producer(push, *(pull[i]), i, bucket_size); });\n+    }\n+\n+    for (int i = 0; i < n_consumers; i++) {\n+        test_threads.create_thread([&, i] { Consumer(push, pull, i, n_producers, bucket_size, n_elements / n_consumers); });\n+    }\n+\n+    test_threads.join_all();\n+\n+    // queue should be empty\n+    BOOST_CHECK_EQUAL(push.size(), 0);\n+    for (int i = 0; i < n_producers; i++) {\n+        BOOST_CHECK_EQUAL(pull[i]->size(), 0);\n+        delete pull[i];\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(invalid_queue, Q, queue_types)\n+{\n+    Q q;\n+    BOOST_CHECK(q.GetCapacity() == 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(basic_operation)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199781485",
      "id" : 199781485,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc4MTQ4NQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 120,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 120,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199781485",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199808121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199808121"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Re: https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196532632\r\n\r\n> I can see this either way - i wrote it with defaults essentially as constructor args because - at least for the use cases i can imagine you almost always want a default mode of operation for a given queue except for certain edge cases (shutdown is the most apparent one) - and i've seen data structures that handle this sort of initialization both ways (defaults on construction vs with every method call) but i'm also happy to change this up if the prevailing opinion is the other way.\r\n\r\nWhat about having Push, Pop, TryPush, and TryPop methods and dropping the enum entirely? I think this would make code using the queue easier to understand, since blocking would be explicit, instead of based on an enum value determined by a combination of method argument, class template argument, method argument default, and class template argument default values. It could also make code using the queue easier to write, since there would no longer be any chance of hitting various compile and runtime checks for invalid enum values.\r\n\r\nI do understand the enum is useful in tests for listing all possible combinations of behavior, but for that purpose, you could just define the enum in test code.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T13:33:17Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199808121",
      "id" : 199808121,
      "in_reply_to_id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTgwODEyMQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T18:03:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199808121",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199811991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199811991"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe add a simple test description like \"Generate messages in \\`n_producers\\` producer threads and push them on to a single \\`push\\` queue. Pop messages from the queue in \\`n_consumers\\` consumer threads, and forward them back to the original producer threads through \\`n_producers\\` different \\`pull\\` queues. Verify all the queues are empty after the threads exit.\"",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T13:44:35Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199811991",
      "id" : 199811991,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTgxMTk5MQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 85,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 85,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199811991",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199812982"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199812982"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe add a simple test description like \"Run QueueTest with different numbers of messages and threads and different queue capacities.\"",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-03T13:47:13Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;\n+    for (int i = 0; i < n_producers; i++)\n+        pull.push_back(new Q(bucket_size));\n+\n+    boost::thread_group test_threads;\n+\n+    for (int i = 0; i < n_producers; i++) {\n+        test_threads.create_thread([&, i] { Producer(push, *(pull[i]), i, bucket_size); });\n+    }\n+\n+    for (int i = 0; i < n_consumers; i++) {\n+        test_threads.create_thread([&, i] { Consumer(push, pull, i, n_producers, bucket_size, n_elements / n_consumers); });\n+    }\n+\n+    test_threads.join_all();\n+\n+    // queue should be empty\n+    BOOST_CHECK_EQUAL(push.size(), 0);\n+    for (int i = 0; i < n_producers; i++) {\n+        BOOST_CHECK_EQUAL(pull[i]->size(), 0);\n+        delete pull[i];\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(invalid_queue, Q, queue_types)\n+{\n+    Q q;\n+    BOOST_CHECK(q.GetCapacity() == 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(basic_operation)\n+{\n+    int n = 10;\n+    QueueBB qBB(n);\n+    QueueBN qBN(n);\n+    QueueNB qNB(n);\n+    QueueNN qNN(n);\n+\n+    BOOST_CHECK((int)qBB.GetCapacity() == n);\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK(qBB.Push(i));\n+        BOOST_CHECK(qBN.Push(i));\n+        BOOST_CHECK(qNB.Push(i));\n+        BOOST_CHECK(qNN.Push(i));\n+    }\n+\n+    BOOST_CHECK(!qNB.Push(0));\n+    BOOST_CHECK(!qNN.Push(0));\n+\n+    int t;\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK_EQUAL(qBB.Pop(), i);\n+\n+        BOOST_CHECK(qBN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+\n+        BOOST_CHECK_EQUAL(qNB.Pop(), i);\n+\n+        BOOST_CHECK(qNN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+    }\n+\n+    int ret;\n+    BOOST_CHECK(!qBN.Pop(ret));\n+    BOOST_CHECK(!qNN.Pop(ret));\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(multithreaded_operation, Q, queue_types)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199812982",
      "id" : 199812982,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTgxMjk4Mg==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 157,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 157,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199812982",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200093380"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200093380"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could also assert that items were popped off in the order they were pushed. ",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-04T11:14:13Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200093380",
      "id" : 200093380,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDA5MzM4MA==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 39,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 39,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200093380",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200132979"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200132979"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Completely agree. This is pretty hard to follow for me as-is.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-04T13:50:23Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200132979",
      "id" : 200132979,
      "in_reply_to_id" : 199772365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEzMjk3OQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 63,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 63,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200132979",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thakns @ryanofsky - agree with basically everything you've said re commit 52ac3b5 - going to wait for some more comments to accumulate and address all at once so i don't mess up any other reviews that might be in progress",
      "created_at" : "2018-07-04T13:56:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-402486739",
      "id" : 402486739,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjQ4NjczOQ==",
      "updated_at" : "2018-07-04T13:56:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402486739",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200135030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200135030"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason this is `protected` in superclasses but `private` here?",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-04T13:56:48Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200135030",
      "id" : 200135030,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDEzNTAzMA==",
      "original_commit_id" : "6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
      "original_position" : 54,
      "path" : "src/core/consumerthread.h",
      "position" : 54,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200135030",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200205851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200205851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why this scope? I think `notify_one()` below can be called while `m_queue_lock` is held. Ã¢ÂÂ same in `Pop()`.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-04T22:11:19Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200205851",
      "id" : 200205851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwNTg1MQ==",
      "original_commit_id" : "9668666b27a9e828c6593cf51b0a1e50a819e08c",
      "original_position" : 71,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 71,
      "pull_request_review_id" : 134475746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200205851",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, could drop `()`. Ã¢ÂÂ same in `Pop()`.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-04T22:20:41Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206332",
      "id" : 200206332,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwNjMzMg==",
      "original_commit_id" : "9668666b27a9e828c6593cf51b0a1e50a819e08c",
      "original_position" : 78,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 78,
      "pull_request_review_id" : 134475746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206332",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206716"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206716"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Readability. It would be nice to be able to see if a push or pop call is blocking just by looking at the call\r\n\r\nI think this comment is spot on.\r\n\r\n>  If you look at other C++ objects that support optional blocking like std::mutex or std::future, the blocking behaviour is determined only by the particular method call\r\n\r\n> What about having Push, Pop, TryPush, and TryPop methods and dropping the enum entirely?\r\n\r\nAgree.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-04T22:27:31Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206716",
      "id" : 200206716,
      "in_reply_to_id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwNjcxNg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 134475746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206716",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200255149"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200255149"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can - but its less efficient to notify on a cv while holding a lock - the thread that you notify will wake up and immediately block again on the lock until you release it. It is safe to call notify without the lock held.\r\n\r\nfrom: https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one\r\n>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this \"hurry up and wait\" scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-05T07:30:34Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200255149",
      "id" : 200255149,
      "in_reply_to_id" : 200205851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDI1NTE0OQ==",
      "original_commit_id" : "9668666b27a9e828c6593cf51b0a1e50a819e08c",
      "original_position" : 71,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 71,
      "pull_request_review_id" : 134533204,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200255149",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-07-07T08:43:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-403199460",
      "id" : 403199460,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMzE5OTQ2MA==",
      "updated_at" : "2018-07-07T08:43:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/403199460",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202417596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202417596"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This thing is pretty complex, and right now it looks like we don't do granular per-thread per-queue shutdowns. The only instance of this being used is shutting down the single thread associated with ValidationQueue. When would a situation arise where we need to shut off some but not all of the threads consuming from a queue? I can't think of a case where that'd be necessary.\r\n\r\nCould we just have the queue itself raise a shutdown signal for the threads? Have `queue->Pop()` return (or set) a sentinel shutdown value of some kind instead? Might save a good bit of code, and would remove the need for some of the locking in ConsumerThread.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-13T17:15:26Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202417596",
      "id" : 202417596,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQxNzU5Ng==",
      "original_commit_id" : "6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
      "original_position" : 48,
      "path" : "src/core/consumerthread.h",
      "position" : 48,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202417596",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202430201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202430201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason this doesn't just live on BlockValidationRequest? Could avoid some friendliness that way.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-13T18:03:49Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+class ValidationLayer;\n+extern std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n+/**\n+ * Encapsulates a request to validate an object (currently only a block)\n+ * Submitted to ValidationLayer for asynchronous validation\n+ *\n+ * @see ValidationLayer\n+ */\n+template <typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+/**\n+ * Holds the results of asynchronous block validation\n+ */\n+struct BlockValidationResponse {\n+    //! Is this the first time this block has been validated\n+    const bool is_new;\n+\n+    //! Did initial validation pass (a block can still pass initial validation but then later fail to connect to an active chain)\n+    const bool block_valid;\n+\n+    BlockValidationResponse(bool _block_valid, bool _is_new)\n+        : is_new(_is_new), block_valid(_block_valid){};\n+};\n+\n+/**\n+ * Encapsulates a request to validate a block\n+ */\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n+\n+    //! Does the validation\n+    void operator()() override;\n+\n+    //! Returns a block hash\n+    std::string GetId() const override;\n+\n+    const ValidationLayer& m_validation_layer;\n+\n+    //! The block to be validated\n+    const std::shared_ptr<const CBlock> m_block;\n+\n+    //! Was this block explicitly requested (currently required by ProcessNewBlock)\n+    const bool m_force_processing;\n+\n+    //! A callback to invoke when ready\n+    //! This is a workaround because c++11 does not support multiplexed waiting on futures\n+    //! In a move to subsequent standards when this behavior is supported this can probably be removed\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: SubmitForValidation(object) -> future<Response>\n+ *  - synchronous:  Validate(object) -> Response (just calls SubmitForValidation and blocks on the response)\n+ *\n+ * Internally, a validation thread pulls validations requests from a queue, processes them and satisfies the promise\n+ * with the result of validation.\n+ */\n+class ValidationLayer\n+{\n+    friend BlockValidationRequest;\n+\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        : m_chainparams(chainparams), m_validation_queue(std::make_shared<ValidationQueue>(100)) {}\n+    ~ValidationLayer(){};\n+\n+    //! Starts the validation layer (creating the validation thread)\n+    void Start();\n+\n+    //! Stops the validation layer (stopping the validation thread)\n+    void Stop();\n+\n+    //! Submit a block for asynchronous validation\n+    std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready = []() {});\n+\n+    //! Submit a block for validation and block on the response\n+    BlockValidationResponse Validate(const std::shared_ptr<const CBlock> block, bool force_processing);\n+\n+private:\n+    //! Internal utility method - sets up and calls ProcessNewBlock\n+    BlockValidationResponse ValidateInternal(const std::shared_ptr<const CBlock> block, bool force_processing) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202430201",
      "id" : 202430201,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQzMDIwMQ==",
      "original_commit_id" : "5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
      "original_position" : 122,
      "path" : "src/validation_layer.h",
      "position" : 122,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202430201",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202432952"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202432952"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Based on the call site, should this be `block_accepted`? \"valid\" is a little ambiguous if you take into account all the different states in `chain.h:BlockStatus`.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-13T18:14:40Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+class ValidationLayer;\n+extern std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n+/**\n+ * Encapsulates a request to validate an object (currently only a block)\n+ * Submitted to ValidationLayer for asynchronous validation\n+ *\n+ * @see ValidationLayer\n+ */\n+template <typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+/**\n+ * Holds the results of asynchronous block validation\n+ */\n+struct BlockValidationResponse {\n+    //! Is this the first time this block has been validated\n+    const bool is_new;\n+\n+    //! Did initial validation pass (a block can still pass initial validation but then later fail to connect to an active chain)\n+    const bool block_valid;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202432952",
      "id" : 202432952,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQzMjk1Mg==",
      "original_commit_id" : "5d40aa8e9607ca8dd35ced29157f28d9602d5d55",
      "original_position" : 49,
      "path" : "src/validation_layer.h",
      "position" : 49,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202432952",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202434170"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202434170"
         }
      },
      "author_association" : "MEMBER",
      "body" : "braces",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-13T18:19:32Z",
      "diff_hunk" : "@@ -2034,11 +2035,28 @@ void CConnman::ThreadMessageHandler()\n             if (pnode->fDisconnect)\n                 continue;\n \n-            // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n-            fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n+            bool request_was_queued = pnode->IsAwaitingInternalRequest();\n+\n+            // If an internal request was queued and it's not done yet, skip this node\n+            if (request_was_queued && !pnode->ProcessInternalRequestResults(m_msgproc))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202434170",
      "id" : 202434170,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQzNDE3MA==",
      "original_commit_id" : "8f0d086d5362de18539471fcfe8f048f8b0c9600",
      "original_position" : 24,
      "path" : "src/net.cpp",
      "position" : 24,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202434170",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202435468"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202435468"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why not just include validation_layer? Circular dep somehow?",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-13T18:24:52Z",
      "diff_hunk" : "@@ -23,19 +23,23 @@\n #include <threadinterrupt.h>\n \n #include <atomic>\n+#include <chrono>\n+#include <condition_variable>\n #include <deque>\n+#include <future>\n+#include <memory>\n #include <stdint.h>\n #include <thread>\n-#include <memory>\n-#include <condition_variable>\n \n #ifndef WIN32\n #include <arpa/inet.h>\n #endif\n \n-\n+struct BlockValidationResponse;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202435468",
      "id" : 202435468,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQzNTQ2OA==",
      "original_commit_id" : "8f0d086d5362de18539471fcfe8f048f8b0c9600",
      "original_position" : 19,
      "path" : "src/net.h",
      "position" : 19,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202435468",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202436224"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202436224"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice cleanup!",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-13T18:27:50Z",
      "diff_hunk" : "@@ -2692,19 +2679,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            forceProcessing = mapBlocksInFlight.count(hash);\n+\n             // mapBlockSource is only used for sending reject messages and DoS scores,\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n-        bool fNewBlock = false;\n-        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n-        if (fNewBlock) {\n-            pfrom->nLastBlockTime = GetTime();\n-        } else {\n-            LOCK(cs_main);\n-            mapBlockSource.erase(pblock->GetHash());\n-        }\n+        SubmitBlock(connman, validation_layer, pfrom, pblock, forceProcessing);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202436224",
      "id" : 202436224,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQzNjIyNA==",
      "original_commit_id" : "8f0d086d5362de18539471fcfe8f048f8b0c9600",
      "original_position" : 171,
      "path" : "src/net_processing.cpp",
      "position" : 146,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202436224",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202436928"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202436928"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm out of my depth here - should be looked at by someone with lots of net_processing experience.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-07-13T18:30:23Z",
      "diff_hunk" : "@@ -3072,6 +3053,26 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+void PeerLogicValidation::ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response)\n+{\n+    LOCK(cs_main);\n+\n+    // If we've reconstructed this block via compactblocks then\n+    // Clear download state for this block, which is in\n+    // process from some other peer.  We do this after calling\n+    // ProcessNewBlock so that a malleated cmpctblock announcement\n+    // can't be used to interfere with block relay.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r202436928",
      "id" : 202436928,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMjQzNjkyOA==",
      "original_commit_id" : "8f0d086d5362de18539471fcfe8f048f8b0c9600",
      "original_position" : 196,
      "path" : "src/net_processing.cpp",
      "position" : 171,
      "pull_request_review_id" : 134339062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-25T17:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/202436928",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-08-08T15:07:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-411439716",
      "id" : 411439716,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxMTQzOTcxNg==",
      "updated_at" : "2018-08-08T15:07:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/411439716",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209697684"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209697684"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement a thread-safe FIFO (producer/consumer style) queue\" (c6396d9ac2d01c43fca7f7730b710de4ba86229c)\r\n\r\nJust noticed this PR is creating a new `src/core/` subdirectory to hold the queue and thread code. This seems good, but it may also be good to add a short `core/README.md` to say what the directory is supposed to be for. For example, if it's meant to hold utility code that isn't bitcoin specific, or if it might make sense in the future to move other code there.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T17:43:58Z",
      "diff_hunk" : "@@ -145,6 +145,7 @@ BITCOIN_CORE_H = \\\n   policy/policy.h \\\n   policy/rbf.h \\\n   pow.h \\\n+  core/producerconsumerqueue.h \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209697684",
      "id" : 209697684,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTY5NzY4NA==",
      "original_commit_id" : "c6396d9ac2d01c43fca7f7730b710de4ba86229c",
      "original_position" : 4,
      "path" : "src/Makefile.am",
      "position" : null,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209697684",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209711909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209711909"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nShould this be marked \"override?\"",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T18:28:40Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209711909",
      "id" : 209711909,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTcxMTkwOQ==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 54,
      "path" : "src/core/consumerthread.h",
      "position" : 54,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209711909",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209712684"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209712684"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nIt might be a good idea to make this abstract (`= 0`) to trigger a compile error in case a subclass declares this the wrong way and fails to override.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T18:31:04Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209712684",
      "id" : 209712684,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTcxMjY4NA==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 26,
      "path" : "src/core/consumerthread.h",
      "position" : 26,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209712684",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209725014"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209725014"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Re: https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196532632\r\n\r\nAnother advantage to add to list above:\r\n\r\n5. If you make blocking an attribute of push/pop methods rather than an attibutes of the queue you can drop the consumer/producer terminology, which I'm finding confusing now that I'm looking at downstream code. E.g. if I push an item into the queue, that seems like producing from my perspective, but it's consuming from the queue/worker thread perspective and makes that code a bit strange, IMO.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T19:10:20Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209725014",
      "id" : 209725014,
      "in_reply_to_id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTcyNTAxNA==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209725014",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209732014"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209732014"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nCalling this variable PRODUCER_MODE here, but passing it as the `consumer_mode` argument to BlockingConsumerQueue/ProducerConsumerQueue is a little unexpected. Could you maybe note this in a short comment to avoid confusion? Alternately it might be clearer just to use `ProducerConsumerQueue` directly, and not have `BlockingConsumerQueue` as a thing.\r\n\r\nTBH, also, I don't actually understand why PRODUCER_MODE exists as a parameter. Why would code constructing WorkQueue want to control the default consumer mode of the queue when it doesn't consume from the queue (ConsumerThread does)?",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T19:35:35Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE>& m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template <WorkerMode PRODUCER_MODE>\n+class WorkQueue : public BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209732014",
      "id" : 209732014,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTczMjAxNA==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 84,
      "path" : "src/core/consumerthread.h",
      "position" : 84,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209732014",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209733049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209733049"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nMight be better to std::move(id) to avoid a copy if caller passes a temporary.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T19:39:12Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE>& m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template <WorkerMode PRODUCER_MODE>\n+class WorkQueue : public BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>\n+{\n+public:\n+    WorkQueue(int capacity) :BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>(capacity) {}\n+\n+    //! Blocks until everything pushed to the queue prior to this call has been dequeued by a worker\n+    void Sync()\n+    {\n+        std::promise<void> barrier;\n+        this->Push(MakeUnique<GenericWorkItem<PRODUCER_MODE>>([&barrier](){ barrier.set_value(); }), WorkerMode::BLOCKING);\n+        barrier.get_future().wait();\n+    }\n+};\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template <WorkerMode PRODUCER_POLICY>\n+class ConsumerThread\n+{\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() : m_active(false){};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"worker\")\n+        : m_id(id), m_queue(queue), m_active(true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209733049",
      "id" : 209733049,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTczMzA0OQ==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 121,
      "path" : "src/core/consumerthread.h",
      "position" : 121,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209733049",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209733925"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209733925"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nCan the comment explain why this is `volatile` rather than `std::atomic` or similar? I thought `volatile` wasn't really meaningful for thread synchronization.\r\n\r\nAlso maybe just write `m_active = true` here so no need to initialize it elsewhere and then describe the initialization in a comment.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T19:42:07Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE>& m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template <WorkerMode PRODUCER_MODE>\n+class WorkQueue : public BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>\n+{\n+public:\n+    WorkQueue(int capacity) :BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>(capacity) {}\n+\n+    //! Blocks until everything pushed to the queue prior to this call has been dequeued by a worker\n+    void Sync()\n+    {\n+        std::promise<void> barrier;\n+        this->Push(MakeUnique<GenericWorkItem<PRODUCER_MODE>>([&barrier](){ barrier.set_value(); }), WorkerMode::BLOCKING);\n+        barrier.get_future().wait();\n+    }\n+};\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template <WorkerMode PRODUCER_POLICY>\n+class ConsumerThread\n+{\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() : m_active(false){};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"worker\")\n+        : m_id(id), m_queue(queue), m_active(true)\n+    {\n+        m_thread = std::thread(&TraceThread<std::function<void()>>, id.c_str(), std::function<void()>(std::bind(&ConsumerThread<PRODUCER_POLICY>::Loop, this)));\n+    };\n+\n+    //! Terminates a running consumer thread\n+    //! Blocks until the thread joins\n+    //! Repeated calls are no-ops\n+    void Terminate()\n+    {\n+        RequestTermination();\n+        Join();\n+    }\n+\n+    //! Requests termination of a running consumer thread\n+    //! Does not wait for the thread to terminate\n+    //! Repeated calls are no-ops\n+    void RequestTermination()\n+    {\n+        // locked only so that repeated calls do not push extra ShutdownPills\n+        std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown);\n+        if (m_active) {\n+            m_active = false;\n+\n+            // push an empty WorkItem so that we wake the thread up if it is blocking on an empty queue\n+            // there is no easy way to determine if this consumer is blocked on the queue without introducing\n+            // additional synchronization, but there is little downside to pushing this unnecessarily:\n+            // either this is the last active thread on the queue in which case this will be destroyed if/when\n+            // the queue (and any other work that may remain is destroyed)\n+            // or there are other threads on the queue - in which case this pill will be discarded after any\n+            // of the other threads observe it more than once\n+            m_queue->Push(std::unique_ptr<ShutdownPill<PRODUCER_POLICY>>(new ShutdownPill<PRODUCER_POLICY>(*this)), WorkerMode::NONBLOCKING);\n+        }\n+    }\n+\n+    //! Waits until this thread terminates\n+    //! RequestTerminate() must have been previously called or be called by a different thread\n+    void Join()\n+    {\n+        m_thread.join();\n+    }\n+\n+    bool IsActive() const { std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown); return m_active; }\n+\n+    const std::string m_id;\n+\n+private:\n+    //! the queue of work that this thread should consume from\n+    const std::shared_ptr<WorkQueue<PRODUCER_POLICY>> m_queue;\n+\n+    //! the thread that this class wraps\n+    std::thread m_thread;\n+\n+    //! whether this thread should continue running: behaves like a latch\n+    //! initialized to true in the constructor",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209733925",
      "id" : 209733925,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTczMzkyNQ==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 175,
      "path" : "src/core/consumerthread.h",
      "position" : 175,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209733925",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209740266"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209740266"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ConsumerThread unit tests\" (134d47a263620afae26f9966a74465bf896ff530)\r\n\r\nWould it make sense to add tests for WorkerMode::NONBLOCKING? Maybe say one way or the other in a comment here even if it is not worth writing more tests now.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T20:04:31Z",
      "diff_hunk" : "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209740266",
      "id" : 209740266,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc0MDI2Ng==",
      "original_commit_id" : "134d47a263620afae26f9966a74465bf896ff530",
      "original_position" : 35,
      "path" : "src/test/consumerthread_tests.cpp",
      "position" : 35,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209740266",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209747179"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209747179"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nWould dropping the mutex and just making `m_active` a `std::atomic` have the same effect? It seems like this would be equivalent and simpler, but maybe you could explain if the mutex is covering something else besides `m_active` in the comment.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T20:27:11Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE>& m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template <WorkerMode PRODUCER_MODE>\n+class WorkQueue : public BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>\n+{\n+public:\n+    WorkQueue(int capacity) :BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>(capacity) {}\n+\n+    //! Blocks until everything pushed to the queue prior to this call has been dequeued by a worker\n+    void Sync()\n+    {\n+        std::promise<void> barrier;\n+        this->Push(MakeUnique<GenericWorkItem<PRODUCER_MODE>>([&barrier](){ barrier.set_value(); }), WorkerMode::BLOCKING);\n+        barrier.get_future().wait();\n+    }\n+};\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template <WorkerMode PRODUCER_POLICY>\n+class ConsumerThread\n+{\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() : m_active(false){};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"worker\")\n+        : m_id(id), m_queue(queue), m_active(true)\n+    {\n+        m_thread = std::thread(&TraceThread<std::function<void()>>, id.c_str(), std::function<void()>(std::bind(&ConsumerThread<PRODUCER_POLICY>::Loop, this)));\n+    };\n+\n+    //! Terminates a running consumer thread\n+    //! Blocks until the thread joins\n+    //! Repeated calls are no-ops\n+    void Terminate()\n+    {\n+        RequestTermination();\n+        Join();\n+    }\n+\n+    //! Requests termination of a running consumer thread\n+    //! Does not wait for the thread to terminate\n+    //! Repeated calls are no-ops\n+    void RequestTermination()\n+    {\n+        // locked only so that repeated calls do not push extra ShutdownPills\n+        std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown);\n+        if (m_active) {\n+            m_active = false;\n+\n+            // push an empty WorkItem so that we wake the thread up if it is blocking on an empty queue\n+            // there is no easy way to determine if this consumer is blocked on the queue without introducing\n+            // additional synchronization, but there is little downside to pushing this unnecessarily:\n+            // either this is the last active thread on the queue in which case this will be destroyed if/when\n+            // the queue (and any other work that may remain is destroyed)\n+            // or there are other threads on the queue - in which case this pill will be discarded after any\n+            // of the other threads observe it more than once\n+            m_queue->Push(std::unique_ptr<ShutdownPill<PRODUCER_POLICY>>(new ShutdownPill<PRODUCER_POLICY>(*this)), WorkerMode::NONBLOCKING);\n+        }\n+    }\n+\n+    //! Waits until this thread terminates\n+    //! RequestTerminate() must have been previously called or be called by a different thread\n+    void Join()\n+    {\n+        m_thread.join();\n+    }\n+\n+    bool IsActive() const { std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown); return m_active; }\n+\n+    const std::string m_id;\n+\n+private:\n+    //! the queue of work that this thread should consume from\n+    const std::shared_ptr<WorkQueue<PRODUCER_POLICY>> m_queue;\n+\n+    //! the thread that this class wraps\n+    std::thread m_thread;\n+\n+    //! whether this thread should continue running: behaves like a latch\n+    //! initialized to true in the constructor\n+    //! can be set to false by calling Terminate()\n+    volatile bool m_active;\n+\n+    //! protects Terminate()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209747179",
      "id" : 209747179,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc0NzE3OQ==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 179,
      "path" : "src/core/consumerthread.h",
      "position" : 179,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209747179",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209748096"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209748096"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ConsumerThread unit tests\" (134d47a263620afae26f9966a74465bf896ff530)\r\n\r\nMaybe shorten this with MakeUnique (also in Push below).",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T20:30:09Z",
      "diff_hunk" : "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));\n+\n+    std::vector<std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>> threads;\n+    for (int i = 0; i < n_threads; i++) {\n+        threads.emplace_back(std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>(new ConsumerThread<WorkerMode::BLOCKING>(queue, std::to_string(i))));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209748096",
      "id" : 209748096,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc0ODA5Ng==",
      "original_commit_id" : "134d47a263620afae26f9966a74465bf896ff530",
      "original_position" : 39,
      "path" : "src/test/consumerthread_tests.cpp",
      "position" : 39,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209748096",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209751301"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209751301"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ConsumerThread unit tests\" (134d47a263620afae26f9966a74465bf896ff530)\r\n\r\nCan you add a comment to say what the yield loop is for? It seems like just calling Sync without yielding beforehand, then then checking size == 0 would be simpler, and also a better check that the `Sync` method works.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T20:40:23Z",
      "diff_hunk" : "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));\n+\n+    std::vector<std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>> threads;\n+    for (int i = 0; i < n_threads; i++) {\n+        threads.emplace_back(std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>(new ConsumerThread<WorkerMode::BLOCKING>(queue, std::to_string(i))));\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        work[i] = i;\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209751301",
      "id" : 209751301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc1MTMwMQ==",
      "original_commit_id" : "134d47a263620afae26f9966a74465bf896ff530",
      "original_position" : 47,
      "path" : "src/test/consumerthread_tests.cpp",
      "position" : 47,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209751301",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209755260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209755260"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ConsumerThread unit tests\" (134d47a263620afae26f9966a74465bf896ff530)\r\n\r\nShould replace foo.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T20:53:59Z",
      "diff_hunk" : "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));\n+\n+    std::vector<std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>> threads;\n+    for (int i = 0; i < n_threads; i++) {\n+        threads.emplace_back(std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>(new ConsumerThread<WorkerMode::BLOCKING>(queue, std::to_string(i))));\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        work[i] = i;\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {\n+        std::this_thread::yield();\n+    }\n+    queue->Sync();\n+\n+    for (int i = 0; i < n_threads / 2; i++) {\n+        threads[i]->Terminate();\n+    }\n+\n+    BOOST_CHECK_LT(queue->size(), n_threads + 1);\n+    for (int i = 0; i < n_elements; i++) {\n+        BOOST_CHECK_EQUAL(work[i], i + 2);\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {\n+        std::this_thread::yield();\n+    }\n+    queue->Sync();\n+\n+    for (int i = n_threads / 2; i < n_threads; i++) {\n+        threads[i]->Terminate();\n+    }\n+\n+    BOOST_CHECK_LT(queue->size(), n_threads + 1);\n+    for (int i = 0; i < n_elements; i++) {\n+        BOOST_CHECK_EQUAL(work[i], i + 4);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(foo)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209755260",
      "id" : 209755260,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc1NTI2MA==",
      "original_commit_id" : "134d47a263620afae26f9966a74465bf896ff530",
      "original_position" : 80,
      "path" : "src/test/consumerthread_tests.cpp",
      "position" : 80,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209755260",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209756189"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209756189"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ConsumerThread unit tests\" (134d47a263620afae26f9966a74465bf896ff530)\r\n\r\nI think there is a race here between `work[i]` being assigned and then incremented in the worker thread. You could avoid it by setting `work` values after creating the vector but before creating the queue.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T20:57:16Z",
      "diff_hunk" : "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));\n+\n+    std::vector<std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>> threads;\n+    for (int i = 0; i < n_threads; i++) {\n+        threads.emplace_back(std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>(new ConsumerThread<WorkerMode::BLOCKING>(queue, std::to_string(i))));\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        work[i] = i;\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209756189",
      "id" : 209756189,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc1NjE4OQ==",
      "original_commit_id" : "134d47a263620afae26f9966a74465bf896ff530",
      "original_position" : 44,
      "path" : "src/test/consumerthread_tests.cpp",
      "position" : 44,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209756189",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209757443"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209757443"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ConsumerThread unit tests\" (134d47a263620afae26f9966a74465bf896ff530)\r\n\r\nMight be good to move this check above Terminate() to make the test more strict.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T21:01:20Z",
      "diff_hunk" : "@@ -0,0 +1,88 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <atomic>\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(consumerthread_tests, BasicTestingSetup)\n+\n+class TestWorkItem : public WorkItem<WorkerMode::BLOCKING>\n+{\n+public:\n+    TestWorkItem(int& i) : m_i(i){};\n+    void operator()()\n+    {\n+        // yield to make unit tests somewhat more unpredictable\n+        std::this_thread::yield();\n+        ++m_i;\n+        std::this_thread::yield();\n+        ++m_i;\n+    }\n+\n+private:\n+    int& m_i;\n+};\n+\n+void ConsumerThreadTest(int n_elements, int n_threads)\n+{\n+    std::vector<int> work(n_elements);\n+    auto queue = std::shared_ptr<WorkQueue<WorkerMode::BLOCKING>>(new WorkQueue<WorkerMode::BLOCKING>(n_elements + 1));\n+\n+    std::vector<std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>> threads;\n+    for (int i = 0; i < n_threads; i++) {\n+        threads.emplace_back(std::unique_ptr<ConsumerThread<WorkerMode::BLOCKING>>(new ConsumerThread<WorkerMode::BLOCKING>(queue, std::to_string(i))));\n+    }\n+\n+    for (int i = 0; i < n_elements; i++) {\n+        work[i] = i;\n+        queue->Push(std::unique_ptr<TestWorkItem>(new TestWorkItem(work[i])));\n+    }\n+\n+    while (queue->size() > 0) {\n+        std::this_thread::yield();\n+    }\n+    queue->Sync();\n+\n+    for (int i = 0; i < n_threads / 2; i++) {\n+        threads[i]->Terminate();\n+    }\n+\n+    BOOST_CHECK_LT(queue->size(), n_threads + 1);\n+    for (int i = 0; i < n_elements; i++) {\n+        BOOST_CHECK_EQUAL(work[i], i + 2);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209757443",
      "id" : 209757443,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc1NzQ0Mw==",
      "original_commit_id" : "134d47a263620afae26f9966a74465bf896ff530",
      "original_position" : 58,
      "path" : "src/test/consumerthread_tests.cpp",
      "position" : 58,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209757443",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209765147"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209765147"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nI think I agree with James. Even if you want to support shutting down specific threads, an approach more like \"Everybody wake up, check if you are supposed to exit, and if not go back to sleep again\" might be simpler than \"Random thread wake up, check if you are supposed to exit, and if not wake up another random thread, but not if you already seen this particular notification before,\" or whatever the correct description is. (If you do want to stick with the current approach, it could be nice to add a high level comment explaining it like this.)",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T21:27:18Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209765147",
      "id" : 209765147,
      "in_reply_to_id" : 202417596,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc2NTE0Nw==",
      "original_commit_id" : "6c624232a71cfb3b7b4de0540b83d5b0dd08c7d7",
      "original_position" : 48,
      "path" : "src/core/consumerthread.h",
      "position" : 48,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209765147",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209766415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209766415"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a888)\r\n\r\nWhy couldn't the intended thread just be blocked calling Pop() and not terminated or currently processing anything? It seems like this is assuming threads are notified in a circular order.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-13T21:32:22Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209766415",
      "id" : 209766415,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTc2NjQxNQ==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 75,
      "path" : "src/core/consumerthread.h",
      "position" : 75,
      "pull_request_review_id" : 145761684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-13T21:59:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209766415",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209983701"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209983701"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ValidationLayer() - interface for calls into block validation\" (b4717281d43b1e0ff9e52d979a3899220ad11eea)\r\n\r\nWould be slightly more efficient to make default on_ready value `nullptr` instead of a no-op lambda.\r\n\r\nIt's also kind of unclear what m_ready is supposed to be used for in this context. You might want to move down your other comment from `m_on_ready` about c++11 futures here.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-14T14:54:22Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+class ValidationLayer;\n+extern std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n+/**\n+ * Encapsulates a request to validate an object (currently only a block)\n+ * Submitted to ValidationLayer for asynchronous validation\n+ *\n+ * @see ValidationLayer\n+ */\n+template <typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+/**\n+ * Holds the results of asynchronous block validation\n+ */\n+struct BlockValidationResponse {\n+    //! Is this the first time this block has been validated\n+    const bool is_new;\n+\n+    //! Did initial validation pass (a block can still pass initial validation but then later fail to connect to an active chain)\n+    const bool block_valid;\n+\n+    BlockValidationResponse(bool _block_valid, bool _is_new)\n+        : is_new(_is_new), block_valid(_block_valid){};\n+};\n+\n+/**\n+ * Encapsulates a request to validate a block\n+ */\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n+\n+    //! Does the validation\n+    void operator()() override;\n+\n+    //! Returns a block hash\n+    std::string GetId() const override;\n+\n+    const ValidationLayer& m_validation_layer;\n+\n+    //! The block to be validated\n+    const std::shared_ptr<const CBlock> m_block;\n+\n+    //! Was this block explicitly requested (currently required by ProcessNewBlock)\n+    const bool m_force_processing;\n+\n+    //! A callback to invoke when ready\n+    //! This is a workaround because c++11 does not support multiplexed waiting on futures\n+    //! In a move to subsequent standards when this behavior is supported this can probably be removed\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: SubmitForValidation(object) -> future<Response>\n+ *  - synchronous:  Validate(object) -> Response (just calls SubmitForValidation and blocks on the response)\n+ *\n+ * Internally, a validation thread pulls validations requests from a queue, processes them and satisfies the promise\n+ * with the result of validation.\n+ */\n+class ValidationLayer\n+{\n+    friend BlockValidationRequest;\n+\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        : m_chainparams(chainparams), m_validation_queue(std::make_shared<ValidationQueue>(100)) {}\n+    ~ValidationLayer(){};\n+\n+    //! Starts the validation layer (creating the validation thread)\n+    void Start();\n+\n+    //! Stops the validation layer (stopping the validation thread)\n+    void Stop();\n+\n+    //! Submit a block for asynchronous validation\n+    std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready = []() {});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r209983701",
      "id" : 209983701,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTk4MzcwMQ==",
      "original_commit_id" : "b4717281d43b1e0ff9e52d979a3899220ad11eea",
      "original_position" : 115,
      "path" : "src/validation_layer.h",
      "position" : 115,
      "pull_request_review_id" : 146103931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-14T21:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209983701",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210090068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210090068"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ValidationLayer() - interface for calls into block validation\" (b4717281d43b1e0ff9e52d979a3899220ad11eea)\r\n\r\nMaybe add the word \"block\" somewhere in here to make it clear what this is validating and obvious this is a block hash.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-14T20:20:28Z",
      "diff_hunk" : "@@ -0,0 +1,54 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <validation_layer.h>\n+#include <validation.h>\n+\n+void BlockValidationRequest::operator()()\n+{\n+    LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210090068",
      "id" : 210090068,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA5MDA2OA==",
      "original_commit_id" : "b4717281d43b1e0ff9e52d979a3899220ad11eea",
      "original_position" : 10,
      "path" : "src/validation_layer.cpp",
      "position" : null,
      "pull_request_review_id" : 146103931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-14T21:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210090068",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210091043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210091043"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ValidationLayer() - interface for calls into block validation\" (b4717281d43b1e0ff9e52d979a3899220ad11eea):\r\n\r\nI think it would be better to just assert `!m_thread` to simplify and be more conservative. If m_thread is allowed to be non-null, then I think you would need to add more synchronization here to make sure join is called before the thread is destroyed to prevent a crash in the destructor: https://en.cppreference.com/w/cpp/thread/thread/%7Ethread",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-14T20:23:46Z",
      "diff_hunk" : "@@ -0,0 +1,54 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <validation_layer.h>\n+#include <validation.h>\n+\n+void BlockValidationRequest::operator()()\n+{\n+    LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());\n+    auto res = m_validation_layer.ValidateInternal(m_block, m_force_processing);\n+    LogPrint(BCLog::VALIDATION, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n+        __func__, GetId(), res.block_valid, res.is_new);\n+\n+    m_promise.set_value(res);\n+    if (m_on_ready) {\n+        m_on_ready();\n+    }\n+}\n+\n+std::string BlockValidationRequest::GetId() const\n+{\n+    return strprintf(\"BlockValidationRequest[%s]\", m_block->GetHash().ToString());\n+}\n+\n+void ValidationLayer::Start()\n+{\n+    assert(!m_thread || !m_thread->IsActive());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210091043",
      "id" : 210091043,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA5MTA0Mw==",
      "original_commit_id" : "b4717281d43b1e0ff9e52d979a3899220ad11eea",
      "original_position" : 28,
      "path" : "src/validation_layer.cpp",
      "position" : 49,
      "pull_request_review_id" : 146103931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-14T21:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210091043",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210096605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210096605"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add ConsumerThread: to consumer and operate on work from a ProducerConsumerQueue\" (7f8a8889564b6509285fbab64825fecb983fca6d)\r\n\r\nI think it would be clearer to just say this will block until RequestTerminate() is called. It should be perfectly fine to call RequestTerminate before or after this call and from any thread.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-14T20:42:38Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                m_consumer.m_queue->Push(MakeUnique<ShutdownPill<MODE>>(std::move(*this)), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE>& m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template <WorkerMode PRODUCER_MODE>\n+class WorkQueue : public BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>\n+{\n+public:\n+    WorkQueue(int capacity) :BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>, PRODUCER_MODE>(capacity) {}\n+\n+    //! Blocks until everything pushed to the queue prior to this call has been dequeued by a worker\n+    void Sync()\n+    {\n+        std::promise<void> barrier;\n+        this->Push(MakeUnique<GenericWorkItem<PRODUCER_MODE>>([&barrier](){ barrier.set_value(); }), WorkerMode::BLOCKING);\n+        barrier.get_future().wait();\n+    }\n+};\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template <WorkerMode PRODUCER_POLICY>\n+class ConsumerThread\n+{\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() : m_active(false){};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"worker\")\n+        : m_id(id), m_queue(queue), m_active(true)\n+    {\n+        m_thread = std::thread(&TraceThread<std::function<void()>>, id.c_str(), std::function<void()>(std::bind(&ConsumerThread<PRODUCER_POLICY>::Loop, this)));\n+    };\n+\n+    //! Terminates a running consumer thread\n+    //! Blocks until the thread joins\n+    //! Repeated calls are no-ops\n+    void Terminate()\n+    {\n+        RequestTermination();\n+        Join();\n+    }\n+\n+    //! Requests termination of a running consumer thread\n+    //! Does not wait for the thread to terminate\n+    //! Repeated calls are no-ops\n+    void RequestTermination()\n+    {\n+        // locked only so that repeated calls do not push extra ShutdownPills\n+        std::unique_lock<CWaitableCriticalSection> l(m_cs_shutdown);\n+        if (m_active) {\n+            m_active = false;\n+\n+            // push an empty WorkItem so that we wake the thread up if it is blocking on an empty queue\n+            // there is no easy way to determine if this consumer is blocked on the queue without introducing\n+            // additional synchronization, but there is little downside to pushing this unnecessarily:\n+            // either this is the last active thread on the queue in which case this will be destroyed if/when\n+            // the queue (and any other work that may remain is destroyed)\n+            // or there are other threads on the queue - in which case this pill will be discarded after any\n+            // of the other threads observe it more than once\n+            m_queue->Push(std::unique_ptr<ShutdownPill<PRODUCER_POLICY>>(new ShutdownPill<PRODUCER_POLICY>(*this)), WorkerMode::NONBLOCKING);\n+        }\n+    }\n+\n+    //! Waits until this thread terminates\n+    //! RequestTerminate() must have been previously called or be called by a different thread",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210096605",
      "id" : 210096605,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA5NjYwNQ==",
      "original_commit_id" : "7f8a8889564b6509285fbab64825fecb983fca6d",
      "original_position" : 157,
      "path" : "src/core/consumerthread.h",
      "position" : 157,
      "pull_request_review_id" : 146103931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-14T21:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210096605",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210097479"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210097479"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ValidationLayer() - interface for calls into block validation\" (b4717281d43b1e0ff9e52d979a3899220ad11eea)\r\n\r\nWould be safer / more efficient to use std::make_shared here.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-14T20:45:18Z",
      "diff_hunk" : "@@ -0,0 +1,54 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <validation_layer.h>\n+#include <validation.h>\n+\n+void BlockValidationRequest::operator()()\n+{\n+    LogPrint(BCLog::VALIDATION, \"%s: validating request=%s\\n\", __func__, GetId());\n+    auto res = m_validation_layer.ValidateInternal(m_block, m_force_processing);\n+    LogPrint(BCLog::VALIDATION, \"%s: validation result request=%s block_valid=%d is_new=%d\\n\",\n+        __func__, GetId(), res.block_valid, res.is_new);\n+\n+    m_promise.set_value(res);\n+    if (m_on_ready) {\n+        m_on_ready();\n+    }\n+}\n+\n+std::string BlockValidationRequest::GetId() const\n+{\n+    return strprintf(\"BlockValidationRequest[%s]\", m_block->GetHash().ToString());\n+}\n+\n+void ValidationLayer::Start()\n+{\n+    assert(!m_thread || !m_thread->IsActive());\n+    m_thread = std::unique_ptr<ValidationThread>(new ValidationThread(m_validation_queue));\n+}\n+\n+void ValidationLayer::Stop()\n+{\n+    assert(m_thread && m_thread->IsActive());\n+    m_thread->Terminate();\n+}\n+\n+std::future<BlockValidationResponse> ValidationLayer::SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready)\n+{\n+    BlockValidationRequest* req = new BlockValidationRequest(*this, block, force_processing, on_ready);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210097479",
      "id" : 210097479,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDA5NzQ3OQ==",
      "original_commit_id" : "b4717281d43b1e0ff9e52d979a3899220ad11eea",
      "original_position" : 40,
      "path" : "src/validation_layer.cpp",
      "position" : 61,
      "pull_request_review_id" : 146103931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-14T21:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210097479",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210100110"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210100110"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ValidationLayer() - interface for calls into block validation\" (b4717281d43b1e0ff9e52d979a3899220ad11eea)\r\n\r\nCan this just be a `ValidationThread` instead of a pointer to one? The extra indirection doesn't seem helpful.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-14T20:54:03Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+class ValidationLayer;\n+extern std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n+/**\n+ * Encapsulates a request to validate an object (currently only a block)\n+ * Submitted to ValidationLayer for asynchronous validation\n+ *\n+ * @see ValidationLayer\n+ */\n+template <typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+/**\n+ * Holds the results of asynchronous block validation\n+ */\n+struct BlockValidationResponse {\n+    //! Is this the first time this block has been validated\n+    const bool is_new;\n+\n+    //! Did initial validation pass (a block can still pass initial validation but then later fail to connect to an active chain)\n+    const bool block_valid;\n+\n+    BlockValidationResponse(bool _block_valid, bool _is_new)\n+        : is_new(_is_new), block_valid(_block_valid){};\n+};\n+\n+/**\n+ * Encapsulates a request to validate a block\n+ */\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n+\n+    //! Does the validation\n+    void operator()() override;\n+\n+    //! Returns a block hash\n+    std::string GetId() const override;\n+\n+    const ValidationLayer& m_validation_layer;\n+\n+    //! The block to be validated\n+    const std::shared_ptr<const CBlock> m_block;\n+\n+    //! Was this block explicitly requested (currently required by ProcessNewBlock)\n+    const bool m_force_processing;\n+\n+    //! A callback to invoke when ready\n+    //! This is a workaround because c++11 does not support multiplexed waiting on futures\n+    //! In a move to subsequent standards when this behavior is supported this can probably be removed\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: SubmitForValidation(object) -> future<Response>\n+ *  - synchronous:  Validate(object) -> Response (just calls SubmitForValidation and blocks on the response)\n+ *\n+ * Internally, a validation thread pulls validations requests from a queue, processes them and satisfies the promise\n+ * with the result of validation.\n+ */\n+class ValidationLayer\n+{\n+    friend BlockValidationRequest;\n+\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        : m_chainparams(chainparams), m_validation_queue(std::make_shared<ValidationQueue>(100)) {}\n+    ~ValidationLayer(){};\n+\n+    //! Starts the validation layer (creating the validation thread)\n+    void Start();\n+\n+    //! Stops the validation layer (stopping the validation thread)\n+    void Stop();\n+\n+    //! Submit a block for asynchronous validation\n+    std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready = []() {});\n+\n+    //! Submit a block for validation and block on the response\n+    BlockValidationResponse Validate(const std::shared_ptr<const CBlock> block, bool force_processing);\n+\n+private:\n+    //! Internal utility method - sets up and calls ProcessNewBlock\n+    BlockValidationResponse ValidateInternal(const std::shared_ptr<const CBlock> block, bool force_processing) const;\n+\n+    //! Internal utility method that wraps a request in a unique pointer and deposits it on the validation queue\n+    template <typename RESPONSE>\n+    std::future<RESPONSE> SubmitForValidation(ValidationRequest<RESPONSE>* request)\n+    {\n+        LogPrint(BCLog::VALIDATION, \"%s<%s>: submitting request=%s\\n\", __func__, typeid(RESPONSE).name(), request->GetId());\n+\n+        auto ret = request->m_promise.get_future();\n+        m_validation_queue->Push(std::unique_ptr<ValidationRequest<RESPONSE>>(request));\n+        return ret;\n+    };\n+\n+    const CChainParams& m_chainparams;\n+\n+    //! a queue that holds validation requests that are sequentially processed by m_thread\n+    const std::shared_ptr<ValidationQueue> m_validation_queue;\n+\n+    //! the validation thread - sequentially processes validation requests from m_validation_queue\n+    std::unique_ptr<ValidationThread> m_thread;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210100110",
      "id" : 210100110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDEwMDExMA==",
      "original_commit_id" : "b4717281d43b1e0ff9e52d979a3899220ad11eea",
      "original_position" : 141,
      "path" : "src/validation_layer.h",
      "position" : 141,
      "pull_request_review_id" : 146103931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-14T21:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210100110",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210101095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210101095"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"ValidationLayer() - interface for calls into block validation\" (b4717281d43b1e0ff9e52d979a3899220ad11eea)\r\n\r\nMaybe assert thread is not joinable here, to help debugging in case this is not shut down correctly.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-14T20:57:25Z",
      "diff_hunk" : "@@ -0,0 +1,144 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+class ValidationLayer;\n+extern std::unique_ptr<ValidationLayer> g_validation_layer;\n+\n+/**\n+ * Encapsulates a request to validate an object (currently only a block)\n+ * Submitted to ValidationLayer for asynchronous validation\n+ *\n+ * @see ValidationLayer\n+ */\n+template <typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    //! Guts of the validation\n+    virtual void operator()() = 0;\n+\n+    //! Returns a string identifier (for logging)\n+    virtual std::string GetId() const = 0;\n+\n+protected:\n+    //! Promise that will deliver the validation result to the caller who generated this request\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+/**\n+ * Holds the results of asynchronous block validation\n+ */\n+struct BlockValidationResponse {\n+    //! Is this the first time this block has been validated\n+    const bool is_new;\n+\n+    //! Did initial validation pass (a block can still pass initial validation but then later fail to connect to an active chain)\n+    const bool block_valid;\n+\n+    BlockValidationResponse(bool _block_valid, bool _is_new)\n+        : is_new(_is_new), block_valid(_block_valid){};\n+};\n+\n+/**\n+ * Encapsulates a request to validate a block\n+ */\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse>\n+{\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+        : m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready){};\n+\n+    //! Does the validation\n+    void operator()() override;\n+\n+    //! Returns a block hash\n+    std::string GetId() const override;\n+\n+    const ValidationLayer& m_validation_layer;\n+\n+    //! The block to be validated\n+    const std::shared_ptr<const CBlock> m_block;\n+\n+    //! Was this block explicitly requested (currently required by ProcessNewBlock)\n+    const bool m_force_processing;\n+\n+    //! A callback to invoke when ready\n+    //! This is a workaround because c++11 does not support multiplexed waiting on futures\n+    //! In a move to subsequent standards when this behavior is supported this can probably be removed\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: SubmitForValidation(object) -> future<Response>\n+ *  - synchronous:  Validate(object) -> Response (just calls SubmitForValidation and blocks on the response)\n+ *\n+ * Internally, a validation thread pulls validations requests from a queue, processes them and satisfies the promise\n+ * with the result of validation.\n+ */\n+class ValidationLayer\n+{\n+    friend BlockValidationRequest;\n+\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        : m_chainparams(chainparams), m_validation_queue(std::make_shared<ValidationQueue>(100)) {}\n+    ~ValidationLayer(){};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210101095",
      "id" : 210101095,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDEwMTA5NQ==",
      "original_commit_id" : "b4717281d43b1e0ff9e52d979a3899220ad11eea",
      "original_position" : 106,
      "path" : "src/validation_layer.h",
      "position" : 106,
      "pull_request_review_id" : 146103931,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-14T21:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210101095",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210326607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210326607"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nShould this also free `g_validation_layer`? (or have a comment saying why it shouldn't be freed)",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T16:27:47Z",
      "diff_hunk" : "@@ -209,6 +211,7 @@ void Shutdown()\n     // using the other before destroying them.\n     if (peerLogic) UnregisterValidationInterface(peerLogic.get());\n     if (g_connman) g_connman->Stop();\n+    if (g_validation_layer) g_validation_layer->Stop();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210326607",
      "id" : 210326607,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDMyNjYwNw==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 20,
      "path" : "src/init.cpp",
      "position" : 20,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:13:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210326607",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210339230"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210339230"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nI think this code might be clearer if the IsAwaitingInternalRequest were call were dropped and ProcessInternalRequestResults just returned requested_was_queued directly. It seems awkward how IsAwaitingInternalRequest and ProcessInternalRequestResults are checking some of the same things and then this code is combining their return values.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T17:11:58Z",
      "diff_hunk" : "@@ -2045,11 +2046,28 @@ void CConnman::ThreadMessageHandler()\n             if (pnode->fDisconnect)\n                 continue;\n \n-            // Receive messages\n-            bool fMoreNodeWork = m_msgproc->ProcessMessages(pnode, flagInterruptMsgProc);\n-            fMoreWork |= (fMoreNodeWork && !pnode->fPauseSend);\n+            bool request_was_queued = pnode->IsAwaitingInternalRequest();\n+\n+            // If an internal request was queued and it's not done yet, skip this node\n+            if (request_was_queued && !pnode->ProcessInternalRequestResults(m_msgproc))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210339230",
      "id" : 210339230,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDMzOTIzMA==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 24,
      "path" : "src/net.cpp",
      "position" : 24,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:13:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210339230",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210342154"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210342154"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nProbably remove, doesn't look like this is used right now.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T17:21:30Z",
      "diff_hunk" : "@@ -18,6 +18,8 @@\n \n #include <boost/thread.hpp>\n \n+class ValidationLayer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210342154",
      "id" : 210342154,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM0MjE1NA==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 4,
      "path" : "src/test/test_bitcoin.h",
      "position" : 4,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:13:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210342154",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210345767"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210345767"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nUnintended indent?",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T17:32:48Z",
      "diff_hunk" : "@@ -1572,7 +1579,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)\n+    bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, ValidationLayer& validation_layer, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210345767",
      "id" : 210345767,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM0NTc2Nw==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 52,
      "path" : "src/net_processing.cpp",
      "position" : 52,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:13:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210345767",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210350141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210350141"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nMaybe drop the !pindex check here, or say in a comment whether this would ever be expected? It seems surprising to treat null pindex like the block is valid.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T17:46:36Z",
      "diff_hunk" : "@@ -3092,6 +3071,26 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+void PeerLogicValidation::ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response)\n+{\n+    LOCK(cs_main);\n+\n+    // If we've reconstructed this block via compactblocks then\n+    // Clear download state for this block, which is in\n+    // process from some other peer.  We do this after calling\n+    // ProcessNewBlock so that a malleated cmpctblock announcement\n+    // can't be used to interfere with block relay.\n+    if (!pindex || pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210350141",
      "id" : 210350141,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM1MDE0MQ==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 172,
      "path" : "src/net_processing.cpp",
      "position" : 172,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:14:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210350141",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210350876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210350876"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nThis seems ok, but I wanted to note that previous code in the fBlockReconstructed case updated nLastBlockTime/mapBlockSource before calling MarkBlockAsReceived, instead of after.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T17:49:01Z",
      "diff_hunk" : "@@ -3092,6 +3071,26 @@ bool PeerLogicValidation::ProcessMessages(CNode* pfrom, std::atomic<bool>& inter\n     return fMoreWork;\n }\n \n+void PeerLogicValidation::ProcessBlockValidationResponse(CNode* pfrom, const std::shared_ptr<const CBlock> pblock, const CBlockIndex* pindex, const BlockValidationResponse& validation_response)\n+{\n+    LOCK(cs_main);\n+\n+    // If we've reconstructed this block via compactblocks then\n+    // Clear download state for this block, which is in\n+    // process from some other peer.  We do this after calling\n+    // ProcessNewBlock so that a malleated cmpctblock announcement\n+    // can't be used to interfere with block relay.\n+    if (!pindex || pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n+        MarkBlockAsReceived(pblock->GetHash());\n+    }\n+\n+    if (validation_response.is_new) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210350876",
      "id" : 210350876,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM1MDg3Ng==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 176,
      "path" : "src/net_processing.cpp",
      "position" : 176,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:14:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210350876",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210353625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210353625"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nShould s/ProcessNewBlock/SubmitBlock/",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T17:55:49Z",
      "diff_hunk" : "@@ -2656,20 +2648,13 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             }\n         } // Don't hold cs_main when we call into ProcessNewBlock",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210353625",
      "id" : 210353625,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM1MzYyNQ==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 107,
      "path" : "src/net_processing.cpp",
      "position" : 107,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:13:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210353625",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210392721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210392721"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f741)\r\n\r\nI guess with this line removed, the block will be marked received later, from the worker thread, after it is processed. This seems ok, though I could see why you might want to mark the block received when its received but before it's processed, so it's clearer what \"received\" and \"processed\" actually refer to.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-15T20:10:11Z",
      "diff_hunk" : "@@ -2645,7 +2638,6 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, reject messages go out, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210392721",
      "id" : 210392721,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDM5MjcyMQ==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 101,
      "path" : "src/net_processing.cpp",
      "position" : 101,
      "pull_request_review_id" : 146517554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-15T21:13:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210392721",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210716022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210716022"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Call ProcessNewBlock() asynchronously in a separate thread from p2p layer\" (1c9f74170f9c35d7bc5ba3e9e079b70aafae4094)\r\n\r\nWould it be possible to assert m_block_validating variables are null/invalid here before overwriting them? It seems like it would help debugging if `SetPendingInternalRequest` were called for a new request before the previous request completed.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-16T19:32:49Z",
      "diff_hunk" : "@@ -2813,6 +2831,37 @@ void CNode::AskFor(const CInv& inv)\n     mapAskFor.insert(std::make_pair(nRequestTime, inv));\n }\n \n+bool CNode::IsAwaitingInternalRequest()\n+{\n+    return m_block_validation_response.valid();\n+}\n+\n+bool CNode::ProcessInternalRequestResults(NetEventsInterface* peerlogic)\n+{\n+    bool all_cleared = true;\n+\n+    if (m_block_validation_response.valid()) {\n+        if (m_block_validation_response.wait_for(std::chrono::milliseconds::zero()) == std::future_status::ready) {\n+            peerlogic->ProcessBlockValidationResponse(this, m_block_validating, m_block_validating_index, m_block_validation_response.get());\n+\n+            m_block_validating = nullptr;\n+            m_block_validating_index = nullptr;\n+            m_block_validation_response = std::future<BlockValidationResponse>();\n+        } else {\n+            all_cleared = false;\n+        }\n+    }\n+\n+    return all_cleared;\n+}\n+\n+void CNode::SetPendingInternalRequest(const std::shared_ptr<const CBlock> block, std::future<BlockValidationResponse>&& pending_response, const CBlockIndex* pindex)\n+{\n+    m_block_validating = block;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210716022",
      "id" : 210716022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDcxNjAyMg==",
      "original_commit_id" : "1c9f74170f9c35d7bc5ba3e9e079b70aafae4094",
      "original_position" : 76,
      "path" : "src/net.cpp",
      "position" : 76,
      "pull_request_review_id" : 146991932,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-16T19:59:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210716022",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210718059"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210718059"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Limit available scope of ProcessNewBlock to ValidationLayer (move-only)\" (377873614b3fa143147ecaba5b750f8be1bdd8a4)\r\n\r\nIt's unusual that ProcessNewBlock is documented and declared in `validation_layer.cpp` but defined in `src/validation.cpp`. It seems like it will make the documentation hard to find. There are a bunch of other options that seem like they would be better to me:\r\n\r\n* Moving `ProcessNewBlock` declaration to `validate_layer.cpp` but moving the documentation to `validate.cpp` near the definition.\r\n* Leaving `ProcessNewBlock` where it is but renaming it to `ProcessNewBlock` internal.\r\n* Making `ProcessNewBlock` a private method of a class that is friends with `ValidationLayer`",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-16T19:40:20Z",
      "diff_hunk" : "@@ -3,7 +3,28 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <validation_layer.h>\n-#include <validation.h>\n+\n+/**\n+ * Process an incoming block. This only returns after the best known valid\n+ * block is made active. Note that it does not, however, guarantee that the\n+ * specific block passed to it has been checked for validity!\n+ *\n+ * If you want to *possibly* get feedback on whether pblock is valid, you must\n+ * install a CValidationInterface (see validationinterface.h) - this will have\n+ * its BlockChecked method called whenever *any* block completes validation.\n+ *\n+ * Note that we guarantee that either the proof-of-work is valid on pblock, or\n+ * (and possibly also) BlockChecked will have been called.\n+ *\n+ * May not be called in a\n+ * validationinterface callback.\n+ *\n+ * @param[in]   pblock  The block we want to process.\n+ * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n+ * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n+ * @return True if state.IsValid()\n+ */\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210718059",
      "id" : 210718059,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDcxODA1OQ==",
      "original_commit_id" : "377873614b3fa143147ecaba5b750f8be1bdd8a4",
      "original_position" : 26,
      "path" : "src/validation_layer.cpp",
      "position" : 27,
      "pull_request_review_id" : 146991932,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-16T19:59:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210718059",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210718249"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210718249"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Limit available scope of ProcessNewBlock to ValidationLayer (move-only)\" (377873614b3fa143147ecaba5b750f8be1bdd8a4)\r\n\r\nLOCKS_EXCLUDED(cs_main) annotation seems to have been dropped here.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-16T19:41:03Z",
      "diff_hunk" : "@@ -3,7 +3,28 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <validation_layer.h>\n-#include <validation.h>\n+\n+/**\n+ * Process an incoming block. This only returns after the best known valid\n+ * block is made active. Note that it does not, however, guarantee that the\n+ * specific block passed to it has been checked for validity!\n+ *\n+ * If you want to *possibly* get feedback on whether pblock is valid, you must\n+ * install a CValidationInterface (see validationinterface.h) - this will have\n+ * its BlockChecked method called whenever *any* block completes validation.\n+ *\n+ * Note that we guarantee that either the proof-of-work is valid on pblock, or\n+ * (and possibly also) BlockChecked will have been called.\n+ *\n+ * May not be called in a\n+ * validationinterface callback.\n+ *\n+ * @param[in]   pblock  The block we want to process.\n+ * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n+ * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n+ * @return True if state.IsValid()\n+ */\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210718249",
      "id" : 210718249,
      "in_reply_to_id" : 210718059,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDcxODI0OQ==",
      "original_commit_id" : "377873614b3fa143147ecaba5b750f8be1bdd8a4",
      "original_position" : 26,
      "path" : "src/validation_layer.cpp",
      "position" : 27,
      "pull_request_review_id" : 146991932,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-16T19:59:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210718249",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210722417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210722417"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Fix whitespace in test_bitcoin.cpp (whitespace,move-only)\" (3d6f03814cde98869ca5b8ad365bb3a0aae522d9)\r\n\r\nMaybe drop \"move-only\" from commit description, since this is actually just a whitespace change.",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-08-16T19:56:01Z",
      "diff_hunk" : "@@ -79,56 +79,56 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n {\n     SetDataDir(\"tempdir\");\n     const CChainParams& chainparams = Params();\n-        // Ideally we'd move all the RPC tests to the functional testing framework\n-        // instead of unit tests, but for now we need these here.\n-\n-        RegisterAllCoreRPCCommands(tableRPC);\n-        ClearDatadirCache();\n-\n-        // We have to run a scheduler thread to prevent ActivateBestChain\n-        // from blocking due to queue overrun.\n-        threadGroup.create_thread(boost::bind(&CScheduler::serviceQueue, &scheduler));\n-        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n-\n-        mempool.setSanityCheck(1.0);\n-        pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-        pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n-        pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n-        if (!LoadGenesisBlock(chainparams)) {\n-            throw std::runtime_error(\"LoadGenesisBlock failed.\");\n-        }\n-        {\n-            CValidationState state;\n-            if (!ActivateBestChain(state, chainparams)) {\n-                throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", FormatStateMessage(state)));\n-            }\n+    // Ideally we'd move all the RPC tests to the functional testing framework",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r210722417",
      "id" : 210722417,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMDcyMjQxNw==",
      "original_commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "original_position" : 27,
      "path" : "src/test/test_bitcoin.cpp",
      "position" : 35,
      "pull_request_review_id" : 146991932,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-08-16T19:59:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/210722417",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r214532349"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532349"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: Ã¢ÂÂtheresÃ¢ÂÂ should be Ã¢ÂÂthere isÃ¢ÂÂ :-)",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-09-02T08:09:01Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r214532349",
      "id" : 214532349,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzMjM0OQ==",
      "original_commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "original_position" : 66,
      "path" : "src/core/consumerthread.h",
      "position" : 66,
      "pull_request_review_id" : 151612772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-09-02T08:09:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532349",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r214532355"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532355"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: Ã¢ÂÂtheresÃ¢ÂÂ should be Ã¢ÂÂthere isÃ¢ÂÂ :-)",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-09-02T08:09:18Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));\n+        }\n+        m_consumer_cv.notify_one();\n+        return true;\n+    };\n+\n+    /**\n+     * Try to pop the oldest element from the front of the queue, if present\n+     * Blocking consumer mode: will always eventually succeed\n+     * Nonblocking consumer mode: Pop() returns failure when the queue is empty\n+     * @param[out] the data popped, if the operation was successful\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    bool Pop(T& data, WorkerMode mode = m_consumer_mode)\n+    {\n+        // attempting a pop from a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() <= 0) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_consumer_cv.wait(l, [&]() { return m_data.size() > 0; });\n+            }\n+\n+            data = std::move(m_data.front());\n+            m_data.pop_front();\n+        }\n+        m_producer_cv.notify_one();\n+        return true;\n+    }\n+\n+    /**\n+     * Shortcut for bool Pop(T&) when consumer mode is blocking\n+     * This must always succeed and thus may only be called in producer blocking mode\n+     * @return the element popped\n+     */\n+    T Pop()\n+    {\n+        static_assert(m_consumer_mode == WorkerMode::BLOCKING, \"\");\n+\n+        T ret;\n+\n+        // use a temporary so theres no side effecting code inside an assert which could be disabled",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r214532355",
      "id" : 214532355,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzMjM1NQ==",
      "original_commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "original_position" : 128,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 128,
      "pull_request_review_id" : 151612776,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-09-02T08:09:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532355",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r214532362"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532362"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: Ã¢ÂÂthatsÃ¢ÂÂ should be Ã¢ÂÂthat isÃ¢ÂÂ :-)",
      "commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "created_at" : "2018-09-02T08:09:47Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_CONSUMERTHREAD_H\n+#define BITCOIN_CORE_CONSUMERTHREAD_H\n+\n+#include <future>\n+#include <thread>\n+\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+\n+template <WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template <WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+template <WorkerMode MODE>\n+class GenericWorkItem : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+public:\n+    GenericWorkItem(std::function<void()> f) : m_f(f) {}\n+\n+protected:\n+    void operator()() override\n+    {\n+        m_f();\n+    }\n+\n+    std::function<void()> m_f;\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template <WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE>\n+{\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer){};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if (std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if (!m_threads_observed.count(id)) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r214532362",
      "id" : 214532362,
      "in_reply_to_id" : 214532349,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzMjM2Mg==",
      "original_commit_id" : "3d6f03814cde98869ca5b8ad365bb3a0aae522d9",
      "original_position" : 66,
      "path" : "src/core/consumerthread.h",
      "position" : 66,
      "pull_request_review_id" : 151612786,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-09-02T08:09:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532362",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--5fd3d806e98f4a0ca80977bb178665a0-->There hasn't been much activity lately and the patch still needs rebase, so I am closing this for now. Please let me know when you want to continue working on this, so the pull request can be re-opened.",
      "created_at" : "2018-12-03T16:19:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-443769361",
      "id" : 443769361,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Mzc2OTM2MQ==",
      "updated_at" : "2018-12-03T16:19:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/443769361",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
